pipeline {
    agent any

    parameters {
        string(name: 'SERVICE_VERSIONS', defaultValue: '{}', description: 'JSON string containing service-specific versions')
        string(name: 'DOCKER_USER', defaultValue: 'luisrojasc', description: 'Docker Hub username')
        booleanParam(name: 'SKIP_E2E_TESTS', defaultValue: false, description: 'Skip E2E tests to speed up deployment')
        booleanParam(name: 'FORCE_DEPLOY_ALL', defaultValue: false, description: 'Force deploy all services (ignore change detection)')
    }

    environment {
        K8S_NAMESPACE = 'dev'
        DOCKER_REGISTRY = 'docker.io'
        ALL_SERVICES = 'service-discovery,user-service,product-service,order-service,payment-service,shipping-service,favourite-service,proxy-client,api-gateway'
        MAX_RETRY_COUNT = '5'
        SERVICE_READINESS_TIMEOUT = '600'
        POD_READY_TIMEOUT = '300'
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 60, unit: 'MINUTES')
        timestamps()
        disableConcurrentBuilds()
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "========================================="
                    echo "  E-Commerce Microservices Deploy (DEV)"
                    echo "  Environment: LOCAL (Minikube/K3s)"
                    echo "  Namespace: ${K8S_NAMESPACE}"
                    echo "  Docker User: ${params.DOCKER_USER}"
                    echo "========================================="
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                }
            }
        }

        stage('Configure kubectl') {
            steps {
                script {
                    echo " Configuring kubectl for local cluster..."
                    sh """
                        kubectl --insecure-skip-tls-verify version --client
                        kubectl --insecure-skip-tls-verify cluster-info
                        kubectl --insecure-skip-tls-verify config set-context --current --namespace=${K8S_NAMESPACE}
                        echo "kubectl configured successfully"
                    """
                }
            }
        }

        stage('Create Namespace') {
            steps {
                script {
                    echo " Ensuring namespace exists..."
                    sh """
                        kubectl --insecure-skip-tls-verify get namespace ${K8S_NAMESPACE} || kubectl --insecure-skip-tls-verify create namespace ${K8S_NAMESPACE}
                        kubectl --insecure-skip-tls-verify get namespace ${K8S_NAMESPACE}
                    """
                }
            }
        }

        stage('Detect Services to Deploy') {
            steps {
                script {
                    def allServices = env.ALL_SERVICES.split(',')
                    def servicesToDeploy = []
                    def serviceVersionMap = [:]

                    if (params.FORCE_DEPLOY_ALL) {
                        echo "  FORCE_DEPLOY_ALL enabled - deploying all services"
                        servicesToDeploy = allServices as List
                        allServices.each { service ->
                            serviceVersionMap[service] = 'latest'
                        }
                    } else {
                        try {
                            // Convert LazyMap to serializable HashMap (don't store JsonSlurper in variable)
                            def parsed = new groovy.json.JsonSlurper().parseText(params.SERVICE_VERSIONS)
                            serviceVersionMap = new HashMap<>(parsed.collectEntries { k, v -> [k.toString(), v.toString()] })

                            serviceVersionMap.each { service, version ->
                                if (version != 'latest' && allServices.contains(service)) {
                                    servicesToDeploy.add(service)
                                }
                            }

                            if (servicesToDeploy.isEmpty()) {
                                echo "  No changed services detected, deploying all as fallback"
                                servicesToDeploy = allServices as List
                                allServices.each { service ->
                                    if (!serviceVersionMap.containsKey(service)) {
                                        serviceVersionMap[service] = 'latest'
                                    }
                                }
                            }

                        } catch (Exception e) {
                            echo "  Failed to parse SERVICE_VERSIONS: ${e.message}"
                            echo "Deploying all services as fallback"
                            servicesToDeploy = allServices as List
                            allServices.each { service ->
                                serviceVersionMap[service] = 'latest'
                            }
                        }
                    }

                    env.SERVICES_TO_DEPLOY = servicesToDeploy.join(',')
                    env.SERVICE_VERSION_MAP = groovy.json.JsonOutput.toJson(serviceVersionMap)

                    echo "========================================="
                    echo "  Deployment Plan"
                    echo "========================================="
                    echo "Services to deploy (${servicesToDeploy.size()}): ${servicesToDeploy.join(', ')}"
                    echo "Services to skip: ${(allServices - servicesToDeploy).join(', ') ?: 'none'}"
                    echo "Version map: ${env.SERVICE_VERSION_MAP}"
                    echo "========================================="
                }
            }
        }

        stage('Cleanup Resources') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def persistentServices = ['postgresql', 'postgres']

                    echo " Cleaning up resources for services to be deployed..."

                    servicesToDeploy.each { service ->
                        if (!persistentServices.contains(service)) {
                            echo "Preparing ${service} for redeployment"
                            sh """
                                set -e
                                kubectl --insecure-skip-tls-verify scale deployment/${service} --replicas=0 -n ${K8S_NAMESPACE} 2>/dev/null || echo "Deployment ${service} not found (first deploy)"
                                kubectl --insecure-skip-tls-verify wait --for=delete pod -l app=${service} -n ${K8S_NAMESPACE} --timeout=60s 2>/dev/null || echo "No pods to delete for ${service}"
                                kubectl --insecure-skip-tls-verify get rs -n ${K8S_NAMESPACE} -l app=${service} --sort-by=.metadata.creationTimestamp -o name 2>/dev/null | head -n -2 | xargs -r kubectl --insecure-skip-tls-verify delete -n ${K8S_NAMESPACE} || true
                                echo "${service} cleanup complete"
                            """
                        }
                    }
                }
            }
        }

        stage('Deploy Infrastructure Services') {
            steps {
                script {
                    def infraServices = ['service-discovery']
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def serviceVersionMap = new HashMap<>(new groovy.json.JsonSlurper().parseText(env.SERVICE_VERSION_MAP))

                    infraServices.each { service ->
                        if (servicesToDeploy.contains(service)) {
                            def version = serviceVersionMap[service] ?: 'latest'
                            def imageTag = "${params.DOCKER_USER}/${service}:${version}"

                            echo " Deploying ${service} (${imageTag})..."

                            // Single shell execution - let kubectl handle waiting
                            sh """
                                set -e
                                echo "Applying manifest for ${service}..."
                                kubectl --insecure-skip-tls-verify apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE}
                                
                                echo "Updating image for ${service}..."
                                kubectl --insecure-skip-tls-verify set image deployment/${service} ${service}=${imageTag} -n ${K8S_NAMESPACE}
                                
                                echo "Restarting deployment ${service}..."
                                kubectl --insecure-skip-tls-verify rollout restart deployment/${service} -n ${K8S_NAMESPACE}
                                
                                echo "Waiting for ${service} to be ready..."
                                kubectl --insecure-skip-tls-verify rollout status deployment/${service} -n ${K8S_NAMESPACE} --timeout=${env.SERVICE_READINESS_TIMEOUT}s
                                
                                echo "${service} deployed successfully"
                            """

                        } else {
                            echo "  Skipping ${service} (no changes)"
                        }
                    }
                }
            }
        }

        stage('Deploy Microservices') {
            steps {
                script {
                    def deploymentOrder = [
                        'user-service',
                        'product-service',
                        'proxy-client',
                        'order-service',
                        'payment-service',
                        'shipping-service',
                        'favourite-service'
                    ]

                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def serviceVersionMap = new HashMap<>(new groovy.json.JsonSlurper().parseText(env.SERVICE_VERSION_MAP))

                    echo " Deploying microservices in order..."

                    deploymentOrder.each { service ->
                        if (servicesToDeploy.contains(service)) {
                            def version = serviceVersionMap[service] ?: 'latest'
                            def imageTag = "${params.DOCKER_USER}/${service}:${version}"

                            echo "Deploying ${service} (${imageTag})..."

                            // Single shell execution - let kubectl handle waiting
                            sh """
                                set -e
                                echo "Applying manifest for ${service}..."
                                kubectl --insecure-skip-tls-verify apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE}
                                
                                echo "Updating image for ${service}..."
                                kubectl --insecure-skip-tls-verify set image deployment/${service} ${service}=${imageTag} -n ${K8S_NAMESPACE}
                                
                                echo "Restarting deployment ${service}..."
                                kubectl --insecure-skip-tls-verify rollout restart deployment/${service} -n ${K8S_NAMESPACE}
                                
                                echo "Waiting for ${service} to be ready..."
                                kubectl --insecure-skip-tls-verify rollout status deployment/${service} -n ${K8S_NAMESPACE} --timeout=${env.SERVICE_READINESS_TIMEOUT}s
                                
                                echo "${service} deployed successfully"
                            """

                        } else {
                            echo "  Skipping ${service} (no changes)"
                        }
                    }
                }
            }
        }

        stage('Deploy API Gateway') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')

                    if (servicesToDeploy.contains('api-gateway')) {
                        def serviceVersionMap = new HashMap<>(new groovy.json.JsonSlurper().parseText(env.SERVICE_VERSION_MAP))
                        def version = serviceVersionMap['api-gateway'] ?: 'latest'
                        def imageTag = "${params.DOCKER_USER}/api-gateway:${version}"

                        echo " Deploying api-gateway (${imageTag})..."

                        // Single shell execution - let kubectl handle waiting
                        sh """
                            set -e
                            echo "Applying manifest for api-gateway..."
                            kubectl --insecure-skip-tls-verify apply -f infrastructure/kubernetes/base/api-gateway.yaml -n ${K8S_NAMESPACE}
                            
                            echo "Updating image for api-gateway..."
                            kubectl --insecure-skip-tls-verify set image deployment/api-gateway api-gateway=${imageTag} -n ${K8S_NAMESPACE}
                            
                            echo "Restarting deployment api-gateway..."
                            kubectl --insecure-skip-tls-verify rollout restart deployment/api-gateway -n ${K8S_NAMESPACE}
                            
                            echo "Waiting for api-gateway to be ready..."
                            kubectl --insecure-skip-tls-verify rollout status deployment/api-gateway -n ${K8S_NAMESPACE} --timeout=${env.SERVICE_READINESS_TIMEOUT}s
                            
                            echo "api-gateway deployed successfully"
                        """

                    } else {
                        echo "  Skipping api-gateway (no changes)"
                    }
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                script {
                    echo " Verifying final deployment state..."
                    sh """
                        echo "========================================="
                        echo "  Deployment Verification"
                        echo "========================================="

                        echo "Pods:"
                        kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} -o wide

                        echo ""
                        echo "Services:"
                        kubectl --insecure-skip-tls-verify get svc -n ${K8S_NAMESPACE}

                        echo ""
                        echo "Checking for pod issues..."
                        PROBLEM_PODS=\$(kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} --field-selector=status.phase!=Running,status.phase!=Succeeded --no-headers 2>/dev/null | wc -l)
                        if [ \$PROBLEM_PODS -gt 0 ]; then
                            echo "Warning: \$PROBLEM_PODS pod(s) not in Running state"
                            kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} --field-selector=status.phase!=Running,status.phase!=Succeeded
                        else
                            echo "All pods are running"
                        fi

                        echo ""
                        echo "Checking for duplicate pods..."
                        SERVICES=\$(echo "${ALL_SERVICES}" | tr ',' ' ')
                        for service in \$SERVICES; do
                            POD_COUNT=\$(kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} -l app=\$service --no-headers 2>/dev/null | wc -l)
                            if [ \$POD_COUNT -gt 1 ]; then
                                echo "Multiple pods found for \$service (\$POD_COUNT pods) - cleaning up..."
                                kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} -l app=\$service --sort-by=.metadata.creationTimestamp --no-headers | head -n -1 | awk '{print \$1}' | xargs -r kubectl --insecure-skip-tls-verify delete pod -n ${K8S_NAMESPACE} || true
                            fi
                        done

                        echo ""
                        echo "========================================="
                        echo "Verification complete"
                        echo "========================================="
                    """
                }
            }
        }

        stage('Get Access URL') {
            steps {
                script {
                    echo " Retrieving access URL..."
                    sh """
                        echo "========================================="
                        echo "  Access Information"
                        echo "========================================="

                        GATEWAY_URL=\$(kubectl --insecure-skip-tls-verify get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)

                        if [ -z "\$GATEWAY_URL" ]; then
                            if command -v minikube &> /dev/null; then
                                GATEWAY_URL=\$(minikube service api-gateway -n ${K8S_NAMESPACE} --url 2>/dev/null || echo "")
                            fi
                        fi

                        if [ -z "\$GATEWAY_URL" ]; then
                            NODE_PORT=\$(kubectl --insecure-skip-tls-verify get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null)
                            if [ -n "\$NODE_PORT" ]; then
                                NODE_IP=\$(kubectl --insecure-skip-tls-verify get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
                                GATEWAY_URL="http://\${NODE_IP}:\${NODE_PORT}"
                            fi
                        fi

                        if [ -n "\$GATEWAY_URL" ]; then
                            echo "API Gateway URL: \$GATEWAY_URL"
                            echo "Health Check: \$GATEWAY_URL/actuator/health"
                            echo "Eureka Dashboard: http://\$(kubectl --insecure-skip-tls-verify get svc service-discovery -n ${K8S_NAMESPACE} -o jsonpath='{.spec.clusterIP}'):8761"
                        else
                            echo "Could not determine external URL"
                            echo "Use: kubectl --insecure-skip-tls-verify port-forward -n ${K8S_NAMESPACE} svc/api-gateway 8080:80"
                        fi

                        echo "========================================="
                    """
                }
            }
        }

        stage('Run E2E Tests') {
            when {
                expression { !params.SKIP_E2E_TESTS }
            }
            steps {
                script {
                    echo " Running E2E tests..."

                    def testsPassed = false
                    def portForwardPid = null

                    try {
                        sh """
                            set +e  # Don't exit on error, we'll handle it
                            
                            echo "========================================="
                            echo "Setting up port-forward to api-gateway..."
                            echo "========================================="
                            
                            # Start port-forward in background
                            kubectl --insecure-skip-tls-verify port-forward -n ${K8S_NAMESPACE} svc/api-gateway 18080:80 > /tmp/port-forward.log 2>&1 &
                            PF_PID=\$!
                            echo \$PF_PID > /tmp/port-forward.pid
                            echo "Port-forward started with PID: \$PF_PID"
                            
                            # Wait and verify port-forward is working
                            echo "Waiting for port-forward to be ready..."
                            for i in {1..30}; do
                                if curl -s -o /dev/null -w "%{http_code}" http://localhost:18080/actuator/health 2>/dev/null | grep -q "200"; then
                                    echo "Port-forward is ready!"
                                    break
                                fi
                                if [ \$i -eq 30 ]; then
                                    echo "Port-forward failed to become ready"
                                    cat /tmp/port-forward.log
                                    exit 1
                                fi
                                echo "Waiting... (\$i/30)"
                                sleep 2
                            done
                            
                            # Test connectivity
                            echo "Testing connectivity to http://localhost:18080..."
                            HEALTH_STATUS=\$(curl -s -o /dev/null -w "%{http_code}" http://localhost:18080/actuator/health)
                            echo "Health check returned: \$HEALTH_STATUS"
                            
                            if [ "\$HEALTH_STATUS" != "200" ]; then
                                echo "Warning: Health check returned \$HEALTH_STATUS, but continuing with tests..."
                            fi
                            
                            echo "========================================="
                            echo "Running Maven E2E Tests..."
                            echo "========================================="
                            
                            # Run tests
                            cd tests
                            mvn clean verify -Pe2e-tests \\
                                -Dtest.base.url=http://localhost:18080 \\
                                -Dtest.timeout=60000 \\
                                -DfailIfNoTests=false
                            
                            TEST_EXIT=\$?
                            
                            # Cleanup
                            echo "========================================="
                            echo "Cleaning up port-forward..."
                            PF_PID=\$(cat /tmp/port-forward.pid 2>/dev/null)
                            if [ -n "\$PF_PID" ]; then
                                kill \$PF_PID 2>/dev/null || true
                                echo "Port-forward (PID: \$PF_PID) terminated"
                            fi
                            
                            # Exit with test result
                            if [ \$TEST_EXIT -eq 0 ]; then
                                echo "========================================="
                                echo "✓ E2E Tests PASSED"
                                echo "========================================="
                            else
                                echo "========================================="
                                echo "✗ E2E Tests FAILED (exit code: \$TEST_EXIT)"
                                echo "========================================="
                            fi
                            
                            exit \$TEST_EXIT
                        """
                        testsPassed = true
                    } catch (Exception e) {
                        echo "  E2E tests failed: ${e.message}"
                        
                        // Cleanup port-forward on error
                        try {
                            sh """
                                PF_PID=\$(cat /tmp/port-forward.pid 2>/dev/null)
                                if [ -n "\$PF_PID" ]; then
                                    kill \$PF_PID 2>/dev/null || true
                                fi
                            """
                        } catch (Exception cleanupError) {
                            echo "Warning: Could not cleanup port-forward: ${cleanupError.message}"
                        }
                        
                        // Show helpful message
                        echo """
========================================
  E2E Tests Failed - Manual Execution
========================================

You can run tests manually from WSL:
cd /mnt/c/Users/luism/OneDrive/Documents/ICESI/IngeSoftV/ecommerce-microservice-backend-app/tests
mvn clean verify -Dtest.base.url="http://\$(minikube ip):32118"

========================================
"""
                        error("E2E tests failed: ${e.message}")
                    }
                }
            }
            post {
                always {
                    junit allowEmptyResults: true, testResults: 'tests/target/failsafe-reports/*.xml'
                }
            }
        }

        stage('Deployment Summary') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def allServices = env.ALL_SERVICES.split(',')
                    def skippedServices = allServices - servicesToDeploy

                    echo """
========================================
  DEPLOYMENT SUMMARY
========================================
Namespace: ${K8S_NAMESPACE}
Docker Registry: ${params.DOCKER_USER}
Git Commit: ${env.GIT_COMMIT_SHORT}

Services Deployed (${servicesToDeploy.size()}):
${servicesToDeploy.collect { "  - ${it}" }.join('\n')}

Services Skipped (${skippedServices.size()}):
${skippedServices.collect { "  - ${it}" }.join('\n') ?: '  (none)'}

Next Steps:
1. Check pods: kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE}
2. Check logs: kubectl --insecure-skip-tls-verify logs -f -l app=<service> -n ${K8S_NAMESPACE}
3. Port forward: kubectl --insecure-skip-tls-verify port-forward -n ${K8S_NAMESPACE} svc/api-gateway 8080:80
========================================
                    """
                }
            }
        }
    }

    post {
        success {
            script {
                echo " DEPLOYMENT SUCCESS"
            }
        }
        failure {
            script {
                echo " DEPLOYMENT FAILED"
                echo "Collecting diagnostic information..."

                sh """
                    kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} || true
                    kubectl --insecure-skip-tls-verify get events -n ${K8S_NAMESPACE} --sort-by=.firstTimestamp | tail -20 || true
                """
            }
        }
        always {
            archiveArtifacts artifacts: 'infrastructure/kubernetes/base/*.yaml', allowEmptyArchive: true
            deleteDir()
        }
    }
}