pipeline {
    agent any

    parameters {
        string(name: 'SERVICE_VERSIONS', defaultValue: '{}', description: 'JSON string containing service-specific versions')
        string(name: 'DOCKER_USER', defaultValue: 'luisrojasc', description: 'Docker Hub username')
        booleanParam(name: 'SKIP_E2E_TESTS', defaultValue: false, description: 'Skip E2E tests to speed up deployment')
        booleanParam(name: 'FORCE_DEPLOY_ALL', defaultValue: false, description: 'Force deploy all services (ignore change detection)')
    }

    environment {
        K8S_NAMESPACE = 'dev'
        DOCKER_REGISTRY = 'docker.io'
        ALL_SERVICES = 'service-discovery,user-service,product-service,order-service,payment-service,shipping-service,favourite-service,proxy-client,api-gateway'
        MAX_RETRY_COUNT = '5'
        SERVICE_READINESS_TIMEOUT = '600'
        POD_READY_TIMEOUT = '300'
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 60, unit: 'MINUTES')
        timestamps()
        disableConcurrentBuilds()
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "========================================="
                    echo "  E-Commerce Microservices Deploy (DEV)"
                    echo "  Environment: LOCAL (Minikube/K3s)"
                    echo "  Namespace: ${K8S_NAMESPACE}"
                    echo "  Docker User: ${params.DOCKER_USER}"
                    echo "========================================="
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                }
            }
        }

        stage('Configure kubectl') {
            steps {
                script {
                    echo " Configuring kubectl for local cluster..."
                    sh """
                        kubectl --insecure-skip-tls-verify version --client
                        kubectl --insecure-skip-tls-verify cluster-info
                        kubectl --insecure-skip-tls-verify config set-context --current --namespace=${K8S_NAMESPACE}
                        echo "kubectl configured successfully"
                    """
                }
            }
        }

        stage('Create Namespace') {
            steps {
                script {
                    echo " Ensuring namespace exists..."
                    sh """
                        kubectl --insecure-skip-tls-verify get namespace ${K8S_NAMESPACE} || kubectl --insecure-skip-tls-verify create namespace ${K8S_NAMESPACE}
                        kubectl --insecure-skip-tls-verify get namespace ${K8S_NAMESPACE}
                    """
                }
            }
        }

        stage('Detect Services to Deploy') {
            steps {
                script {
                    def allServices = env.ALL_SERVICES.split(',')
                    def servicesToDeploy = []
                    def serviceVersionMap = [:]

                    if (params.FORCE_DEPLOY_ALL) {
                        echo "  FORCE_DEPLOY_ALL enabled - deploying all services"
                        servicesToDeploy = allServices as List
                        allServices.each { service ->
                            serviceVersionMap[service] = 'latest'
                        }
                    } else {
                        try {
                            def slurper = new groovy.json.JsonSlurper()
                            def parsed = slurper.parseText(params.SERVICE_VERSIONS)
                            serviceVersionMap = parsed.collectEntries { k, v -> [k.toString(), v.toString()] }

                            serviceVersionMap.each { service, version ->
                                if (version != 'latest' && allServices.contains(service)) {
                                    servicesToDeploy.add(service)
                                }
                            }

                            if (servicesToDeploy.isEmpty()) {
                                echo "  No changed services detected, deploying all as fallback"
                                servicesToDeploy = allServices as List
                                allServices.each { service ->
                                    if (!serviceVersionMap.containsKey(service)) {
                                        serviceVersionMap[service] = 'latest'
                                    }
                                }
                            }

                        } catch (Exception e) {
                            echo "  Failed to parse SERVICE_VERSIONS: ${e.message}"
                            echo "Deploying all services as fallback"
                            servicesToDeploy = allServices as List
                            allServices.each { service ->
                                serviceVersionMap[service] = 'latest'
                            }
                        }
                    }

                    env.SERVICES_TO_DEPLOY = servicesToDeploy.join(',')
                    env.SERVICE_VERSION_MAP = groovy.json.JsonOutput.toJson(serviceVersionMap)

                    echo "========================================="
                    echo "  Deployment Plan"
                    echo "========================================="
                    echo "Services to deploy (${servicesToDeploy.size()}): ${servicesToDeploy.join(', ')}"
                    echo "Services to skip: ${(allServices - servicesToDeploy).join(', ') ?: 'none'}"
                    echo "Version map: ${env.SERVICE_VERSION_MAP}"
                    echo "========================================="
                }
            }
        }

        stage('Cleanup Resources') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def persistentServices = ['postgresql', 'postgres']

                    echo " Cleaning up resources for services to be deployed..."

                    servicesToDeploy.each { service ->
                        if (!persistentServices.contains(service)) {
                            echo "Preparing ${service} for redeployment"
                            sh """
                                set -e
                                kubectl --insecure-skip-tls-verify scale deployment/${service} --replicas=0 -n ${K8S_NAMESPACE} 2>/dev/null || echo "Deployment ${service} not found (first deploy)"
                                kubectl --insecure-skip-tls-verify wait --for=delete pod -l app=${service} -n ${K8S_NAMESPACE} --timeout=60s 2>/dev/null || echo "No pods to delete for ${service}"
                                kubectl --insecure-skip-tls-verify get rs -n ${K8S_NAMESPACE} -l app=${service} --sort-by=.metadata.creationTimestamp -o name 2>/dev/null | head -n -2 | xargs -r kubectl --insecure-skip-tls-verify delete -n ${K8S_NAMESPACE} || true
                                echo "${service} cleanup complete"
                            """
                        }
                    }
                }
            }
        }

        stage('Deploy Infrastructure Services') {
            steps {
                script {
                    def infraServices = ['service-discovery']
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def slurper = new groovy.json.JsonSlurper()
                    def serviceVersionMap = slurper.parseText(env.SERVICE_VERSION_MAP)

                    infraServices.each { service ->
                        if (servicesToDeploy.contains(service)) {
                            def version = serviceVersionMap[service] ?: 'latest'
                            def imageTag = "${params.DOCKER_USER}/${service}:${version}"

                            echo " Deploying ${service} (${imageTag})..."

                            // Execute kubectl commands with explicit output handling
                            sh script: "kubectl --insecure-skip-tls-verify apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE} 2>&1", returnStatus: false
                            sh script: "kubectl --insecure-skip-tls-verify set image deployment/${service} ${service}=${imageTag} -n ${K8S_NAMESPACE} 2>&1", returnStatus: false
                            sh script: "kubectl --insecure-skip-tls-verify rollout restart deployment/${service} -n ${K8S_NAMESPACE} 2>&1", returnStatus: false

                            // Wait using Groovy (Jenkins-safe)
                            def timeoutSeconds = env.SERVICE_READINESS_TIMEOUT.toInteger()
                            def checkInterval = 2
                            def maxAttempts = timeoutSeconds / checkInterval
                            def available = false

                            echo "Waiting for deployment/${service} to become available (timeout: ${timeoutSeconds}s)..."

                            for (int i = 0; i < maxAttempts; i++) {
                                try {
                                    def output = sh(
                                        script: "kubectl --insecure-skip-tls-verify get deployment/${service} -n ${K8S_NAMESPACE} -o jsonpath='{.status.availableReplicas}' 2>/dev/null",
                                        returnStdout: true
                                    ).trim()

                                    if (output == "1") {
                                        available = true
                                        echo "${service} is available"
                                        break
                                    }
                                } catch (Exception e) {
                                    // Ignore errors during checks
                                }

                                echo "Still waiting... (${new Date().format('HH:mm:ss')})"
                                sleep(checkInterval)
                            }

                            if (!available) {
                                error("Timeout: deployment/${service} did not become available within ${timeoutSeconds} seconds")
                            }

                        } else {
                            echo "  Skipping ${service} (no changes)"
                        }
                    }
                }
            }
        }

        stage('Deploy Microservices') {
            steps {
                script {
                    def deploymentOrder = [
                        'user-service',
                        'product-service',
                        'proxy-client',
                        'order-service',
                        'payment-service',
                        'shipping-service',
                        'favourite-service'
                    ]

                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def slurper = new groovy.json.JsonSlurper()
                    def serviceVersionMap = slurper.parseText(env.SERVICE_VERSION_MAP)

                    echo " Deploying microservices in order..."

                    deploymentOrder.each { service ->
                        if (servicesToDeploy.contains(service)) {
                            def version = serviceVersionMap[service] ?: 'latest'
                            def imageTag = "${params.DOCKER_USER}/${service}:${version}"

                            echo "Deploying ${service} (${imageTag})..."

                            // Execute kubectl commands with explicit output handling
                            sh script: "kubectl --insecure-skip-tls-verify apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE} 2>&1", returnStatus: false
                            sh script: "kubectl --insecure-skip-tls-verify set image deployment/${service} ${service}=${imageTag} -n ${K8S_NAMESPACE} 2>&1", returnStatus: false
                            sh script: "kubectl --insecure-skip-tls-verify rollout restart deployment/${service} -n ${K8S_NAMESPACE} 2>&1", returnStatus: false

                            // Wait using Groovy (Jenkins-safe)
                            def timeoutSeconds = env.SERVICE_READINESS_TIMEOUT.toInteger()
                            def checkInterval = 2
                            def maxAttempts = timeoutSeconds / checkInterval
                            def available = false

                            echo "Waiting for deployment/${service} to become available (timeout: ${timeoutSeconds}s)..."

                            for (int i = 0; i < maxAttempts; i++) {
                                try {
                                    def output = sh(
                                        script: "kubectl --insecure-skip-tls-verify get deployment/${service} -n ${K8S_NAMESPACE} -o jsonpath='{.status.availableReplicas}' 2>/dev/null",
                                        returnStdout: true
                                    ).trim()

                                    if (output == "1") {
                                        available = true
                                        echo "${service} is available"
                                        break
                                    }
                                } catch (Exception e) {
                                    // Ignore errors during checks
                                }

                                echo "Still waiting... (${new Date().format('HH:mm:ss')})"
                                sleep(checkInterval)
                            }

                            if (!available) {
                                error("Timeout: deployment/${service} did not become available within ${timeoutSeconds} seconds")
                            }

                        } else {
                            echo "  Skipping ${service} (no changes)"
                        }
                    }
                }
            }
        }

        stage('Deploy API Gateway') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')

                    if (servicesToDeploy.contains('api-gateway')) {
                        def slurper = new groovy.json.JsonSlurper()
                        def serviceVersionMap = slurper.parseText(env.SERVICE_VERSION_MAP)
                        def version = serviceVersionMap['api-gateway'] ?: 'latest'
                        def imageTag = "${params.DOCKER_USER}/api-gateway:${version}"

                        echo " Deploying api-gateway (${imageTag})..."

                        // Execute kubectl commands with explicit output handling
                        sh script: "kubectl --insecure-skip-tls-verify apply -f infrastructure/kubernetes/base/api-gateway.yaml -n ${K8S_NAMESPACE} 2>&1", returnStatus: false
                        sh script: "kubectl --insecure-skip-tls-verify set image deployment/api-gateway api-gateway=${imageTag} -n ${K8S_NAMESPACE} 2>&1", returnStatus: false
                        sh script: "kubectl --insecure-skip-tls-verify rollout restart deployment/api-gateway -n ${K8S_NAMESPACE} 2>&1", returnStatus: false

                        // Wait using Groovy (Jenkins-safe)
                        def timeoutSeconds = env.SERVICE_READINESS_TIMEOUT.toInteger()
                        def checkInterval = 2
                        def maxAttempts = timeoutSeconds / checkInterval
                        def available = false

                        echo "Waiting for deployment/api-gateway to become available (timeout: ${timeoutSeconds}s)..."

                        for (int i = 0; i < maxAttempts; i++) {
                            try {
                                def output = sh(
                                    script: "kubectl --insecure-skip-tls-verify get deployment/api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.status.availableReplicas}' 2>/dev/null",
                                    returnStdout: true
                                ).trim()

                                if (output == "1") {
                                    available = true
                                    echo "api-gateway is available"
                                    break
                                }
                            } catch (Exception e) {
                                // Ignore errors during checks
                            }

                            echo "Still waiting... (${new Date().format('HH:mm:ss')})"
                            sleep(checkInterval)
                        }

                        if (!available) {
                            error("Timeout: deployment/api-gateway did not become available within ${timeoutSeconds} seconds")
                        }

                    } else {
                        echo "  Skipping api-gateway (no changes)"
                    }
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                script {
                    echo " Verifying final deployment state..."
                    sh """
                        echo "========================================="
                        echo "  Deployment Verification"
                        echo "========================================="

                        echo "Pods:"
                        kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} -o wide

                        echo ""
                        echo "Services:"
                        kubectl --insecure-skip-tls-verify get svc -n ${K8S_NAMESPACE}

                        echo ""
                        echo "Checking for pod issues..."
                        PROBLEM_PODS=\$(kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} --field-selector=status.phase!=Running,status.phase!=Succeeded --no-headers 2>/dev/null | wc -l)
                        if [ \$PROBLEM_PODS -gt 0 ]; then
                            echo "Warning: \$PROBLEM_PODS pod(s) not in Running state"
                            kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} --field-selector=status.phase!=Running,status.phase!=Succeeded
                        else
                            echo "All pods are running"
                        fi

                        echo ""
                        echo "Checking for duplicate pods..."
                        SERVICES=\$(echo "${ALL_SERVICES}" | tr ',' ' ')
                        for service in \$SERVICES; do
                            POD_COUNT=\$(kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} -l app=\$service --no-headers 2>/dev/null | wc -l)
                            if [ \$POD_COUNT -gt 1 ]; then
                                echo "Multiple pods found for \$service (\$POD_COUNT pods) - cleaning up..."
                                kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} -l app=\$service --sort-by=.metadata.creationTimestamp --no-headers | head -n -1 | awk '{print \$1}' | xargs -r kubectl --insecure-skip-tls-verify delete pod -n ${K8S_NAMESPACE} || true
                            fi
                        done

                        echo ""
                        echo "========================================="
                        echo "Verification complete"
                        echo "========================================="
                    """
                }
            }
        }

        stage('Get Access URL') {
            steps {
                script {
                    echo " Retrieving access URL..."
                    sh """
                        echo "========================================="
                        echo "  Access Information"
                        echo "========================================="

                        GATEWAY_URL=\$(kubectl --insecure-skip-tls-verify get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)

                        if [ -z "\$GATEWAY_URL" ]; then
                            if command -v minikube &> /dev/null; then
                                GATEWAY_URL=\$(minikube service api-gateway -n ${K8S_NAMESPACE} --url 2>/dev/null || echo "")
                            fi
                        fi

                        if [ -z "\$GATEWAY_URL" ]; then
                            NODE_PORT=\$(kubectl --insecure-skip-tls-verify get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null)
                            if [ -n "\$NODE_PORT" ]; then
                                NODE_IP=\$(kubectl --insecure-skip-tls-verify get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
                                GATEWAY_URL="http://\${NODE_IP}:\${NODE_PORT}"
                            fi
                        fi

                        if [ -n "\$GATEWAY_URL" ]; then
                            echo "API Gateway URL: \$GATEWAY_URL"
                            echo "Health Check: \$GATEWAY_URL/actuator/health"
                            echo "Eureka Dashboard: http://\$(kubectl --insecure-skip-tls-verify get svc service-discovery -n ${K8S_NAMESPACE} -o jsonpath='{.spec.clusterIP}'):8761"
                        else
                            echo "Could not determine external URL"
                            echo "Use: kubectl --insecure-skip-tls-verify port-forward -n ${K8S_NAMESPACE} svc/api-gateway 8080:80"
                        fi

                        echo "========================================="
                    """
                }
            }
        }

        stage('Run E2E Tests') {
            when {
                expression { !params.SKIP_E2E_TESTS }
            }
            steps {
                script {
                    echo " Running E2E tests..."

                    try {
                        sh """
                            echo "Waiting for services to stabilize (60s)..."
                            sleep 60

                            GATEWAY_URL=\$(kubectl --insecure-skip-tls-verify get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)

                            if [ -z "\$GATEWAY_URL" ]; then
                                if command -v minikube &> /dev/null; then
                                    GATEWAY_URL=\$(minikube service api-gateway -n ${K8S_NAMESPACE} --url 2>/dev/null | head -1)
                                fi
                            fi

                            if [ -z "\$GATEWAY_URL" ]; then
                                NODE_PORT=\$(kubectl --insecure-skip-tls-verify get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.spec.ports[0].nodePort}')
                                NODE_IP=\$(kubectl --insecure-skip-tls-verify get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
                                GATEWAY_URL="http://\${NODE_IP}:\${NODE_PORT}"
                            fi

                            echo "Testing against: \$GATEWAY_URL"

                            cd tests
                            mvn clean verify -Pe2e-tests \\
                                -Dtest.base.url=\$GATEWAY_URL \\
                                -Dtest.timeout=60000 \\
                                -DfailIfNoTests=false
                        """
                    } catch (Exception e) {
                        echo "  E2E tests failed or could not run: ${e.message}"
                        error("E2E tests failed: ${e.message}")
                    }
                }
            }
            post {
                always {
                    junit allowEmptyResults: true, testResults: 'tests/target/failsafe-reports/*.xml'
                }
            }
        }

        stage('Deployment Summary') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def allServices = env.ALL_SERVICES.split(',')
                    def skippedServices = allServices - servicesToDeploy

                    echo """
========================================
  DEPLOYMENT SUMMARY
========================================
Namespace: ${K8S_NAMESPACE}
Docker Registry: ${params.DOCKER_USER}
Git Commit: ${env.GIT_COMMIT_SHORT}

Services Deployed (${servicesToDeploy.size()}):
${servicesToDeploy.collect { "  - ${it}" }.join('\n')}

Services Skipped (${skippedServices.size()}):
${skippedServices.collect { "  - ${it}" }.join('\n') ?: '  (none)'}

Next Steps:
1. Check pods: kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE}
2. Check logs: kubectl --insecure-skip-tls-verify logs -f -l app=<service> -n ${K8S_NAMESPACE}
3. Port forward: kubectl --insecure-skip-tls-verify port-forward -n ${K8S_NAMESPACE} svc/api-gateway 8080:80
========================================
                    """
                }
            }
        }
    }

    post {
        success {
            script {
                echo " DEPLOYMENT SUCCESS"
            }
        }
        failure {
            script {
                echo " DEPLOYMENT FAILED"
                echo "Collecting diagnostic information..."

                sh """
                    kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} || true
                    kubectl --insecure-skip-tls-verify get events -n ${K8S_NAMESPACE} --sort-by=.firstTimestamp | tail -20 || true
                """
            }
        }
        always {
            archiveArtifacts artifacts: 'infrastructure/kubernetes/base/*.yaml', allowEmptyArchive: true
            deleteDir()
        }
    }
}