pipeline {
    agent any

    parameters {
        string(name: 'SERVICE_VERSIONS', defaultValue: '{}', description: 'JSON string containing service-specific versions')
        string(name: 'DOCKER_USER', defaultValue: 'luisrojasc', description: 'Docker Hub username')
        booleanParam(name: 'SKIP_E2E_TESTS', defaultValue: false, description: 'Skip E2E tests to speed up deployment')
        booleanParam(name: 'FORCE_DEPLOY_ALL', defaultValue: false, description: 'Force deploy all services (ignore change detection)')
    }

    environment {
        K8S_NAMESPACE = 'dev'
        DOCKER_REGISTRY = 'docker.io'
        ALL_SERVICES = 'service-discovery,user-service,product-service,order-service,payment-service,shipping-service,favourite-service,proxy-client,api-gateway'
        MAX_RETRY_COUNT = '5'
        SERVICE_READINESS_TIMEOUT = '600'
        POD_READY_TIMEOUT = '300'
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 60, unit: 'MINUTES')
        timestamps()
        disableConcurrentBuilds()
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "========================================="
                    echo "  E-Commerce Microservices Deploy (DEV)"
                    echo "  Environment: LOCAL (Minikube/K3s)"
                    echo "  Namespace: ${K8S_NAMESPACE}"
                    echo "  Docker User: ${params.DOCKER_USER}"
                    echo "========================================="
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                }
            }
        }

        stage('Configure kubectl') {
            steps {
                script {
                    echo " Configuring kubectl for local cluster..."
                    sh """
                        kubectl --insecure-skip-tls-verify version --client
                        kubectl --insecure-skip-tls-verify cluster-info
                        kubectl --insecure-skip-tls-verify config set-context --current --namespace=${K8S_NAMESPACE}
                        echo "kubectl configured successfully"
                    """
                }
            }
        }

        stage('Create Namespace') {
            steps {
                script {
                    echo " Ensuring namespace exists..."
                    sh """
                        kubectl --insecure-skip-tls-verify get namespace ${K8S_NAMESPACE} || kubectl --insecure-skip-tls-verify create namespace ${K8S_NAMESPACE}
                        kubectl --insecure-skip-tls-verify get namespace ${K8S_NAMESPACE}
                    """
                }
            }
        }

        stage('Detect Services to Deploy') {
            steps {
                script {
                    def allServices = env.ALL_SERVICES.split(',')
                    def servicesToDeploy = []
                    def serviceVersionMap = [:]

                    if (params.FORCE_DEPLOY_ALL) {
                        echo "  FORCE_DEPLOY_ALL enabled - deploying all services"
                        servicesToDeploy = allServices as List
                        allServices.each { service ->
                            serviceVersionMap[service] = 'latest'
                        }
                    } else {
                        try {
                            // Convert LazyMap to serializable HashMap (don't store JsonSlurper in variable)
                            def parsed = new groovy.json.JsonSlurper().parseText(params.SERVICE_VERSIONS)
                            serviceVersionMap = new HashMap<>(parsed.collectEntries { k, v -> [k.toString(), v.toString()] })

                            serviceVersionMap.each { service, version ->
                                if (version != 'latest' && allServices.contains(service)) {
                                    servicesToDeploy.add(service)
                                }
                            }

                            if (servicesToDeploy.isEmpty()) {
                                echo "  No changed services detected, deploying all as fallback"
                                servicesToDeploy = allServices as List
                                allServices.each { service ->
                                    if (!serviceVersionMap.containsKey(service)) {
                                        serviceVersionMap[service] = 'latest'
                                    }
                                }
                            }

                        } catch (Exception e) {
                            echo "  Failed to parse SERVICE_VERSIONS: ${e.message}"
                            echo "Deploying all services as fallback"
                            servicesToDeploy = allServices as List
                            allServices.each { service ->
                                serviceVersionMap[service] = 'latest'
                            }
                        }
                    }

                    env.SERVICES_TO_DEPLOY = servicesToDeploy.join(',')
                    env.SERVICE_VERSION_MAP = groovy.json.JsonOutput.toJson(serviceVersionMap)

                    echo "========================================="
                    echo "  Deployment Plan"
                    echo "========================================="
                    echo "Services to deploy (${servicesToDeploy.size()}): ${servicesToDeploy.join(', ')}"
                    echo "Services to skip: ${(allServices - servicesToDeploy).join(', ') ?: 'none'}"
                    echo "Version map: ${env.SERVICE_VERSION_MAP}"
                    echo "========================================="
                }
            }
        }

        stage('Cleanup Resources') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def persistentServices = ['postgresql', 'postgres']

                    echo " Cleaning up resources for services to be deployed..."

                    servicesToDeploy.each { service ->
                        if (!persistentServices.contains(service)) {
                            echo "Preparing ${service} for redeployment"
                            sh """
                                set -e
                                kubectl --insecure-skip-tls-verify scale deployment/${service} --replicas=0 -n ${K8S_NAMESPACE} 2>/dev/null || echo "Deployment ${service} not found (first deploy)"
                                kubectl --insecure-skip-tls-verify wait --for=delete pod -l app=${service} -n ${K8S_NAMESPACE} --timeout=60s 2>/dev/null || echo "No pods to delete for ${service}"
                                kubectl --insecure-skip-tls-verify get rs -n ${K8S_NAMESPACE} -l app=${service} --sort-by=.metadata.creationTimestamp -o name 2>/dev/null | head -n -2 | xargs -r kubectl --insecure-skip-tls-verify delete -n ${K8S_NAMESPACE} || true
                                echo "${service} cleanup complete"
                            """
                        }
                    }
                }
            }
        }

        stage('Deploy Infrastructure Services') {
            steps {
                script {
                    def infraServices = ['service-discovery']
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def serviceVersionMap = new HashMap<>(new groovy.json.JsonSlurper().parseText(env.SERVICE_VERSION_MAP))

                    infraServices.each { service ->
                        if (servicesToDeploy.contains(service)) {
                            def version = serviceVersionMap[service] ?: 'latest'
                            def imageTag = "${params.DOCKER_USER}/${service}:${version}"

                            echo " Deploying ${service} (${imageTag})..."

                            // Single shell execution - let kubectl handle waiting
                            sh """
                                set -e
                                echo "Applying manifest for ${service}..."
                                kubectl --insecure-skip-tls-verify apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE}
                                
                                echo "Updating image for ${service}..."
                                kubectl --insecure-skip-tls-verify set image deployment/${service} ${service}=${imageTag} -n ${K8S_NAMESPACE}
                                
                                echo "Restarting deployment ${service}..."
                                kubectl --insecure-skip-tls-verify rollout restart deployment/${service} -n ${K8S_NAMESPACE}
                                
                                echo "Waiting for ${service} to be ready..."
                                kubectl --insecure-skip-tls-verify rollout status deployment/${service} -n ${K8S_NAMESPACE} --timeout=${env.SERVICE_READINESS_TIMEOUT}s
                                
                                echo "${service} deployed successfully"
                            """

                        } else {
                            echo "  Skipping ${service} (no changes)"
                        }
                    }
                }
            }
        }

        stage('Deploy Microservices') {
            steps {
                script {
                    def deploymentOrder = [
                        'user-service',
                        'product-service',
                        'proxy-client',
                        'order-service',
                        'payment-service',
                        'shipping-service',
                        'favourite-service'
                    ]

                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def serviceVersionMap = new HashMap<>(new groovy.json.JsonSlurper().parseText(env.SERVICE_VERSION_MAP))

                    echo " Deploying microservices in order..."

                    deploymentOrder.each { service ->
                        if (servicesToDeploy.contains(service)) {
                            def version = serviceVersionMap[service] ?: 'latest'
                            def imageTag = "${params.DOCKER_USER}/${service}:${version}"

                            echo "Deploying ${service} (${imageTag})..."

                            // Single shell execution - let kubectl handle waiting
                            sh """
                                set -e
                                echo "Applying manifest for ${service}..."
                                kubectl --insecure-skip-tls-verify apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE}
                                
                                echo "Updating image for ${service}..."
                                kubectl --insecure-skip-tls-verify set image deployment/${service} ${service}=${imageTag} -n ${K8S_NAMESPACE}
                                
                                echo "Restarting deployment ${service}..."
                                kubectl --insecure-skip-tls-verify rollout restart deployment/${service} -n ${K8S_NAMESPACE}
                                
                                echo "Waiting for ${service} to be ready..."
                                kubectl --insecure-skip-tls-verify rollout status deployment/${service} -n ${K8S_NAMESPACE} --timeout=${env.SERVICE_READINESS_TIMEOUT}s
                                
                                echo "${service} deployed successfully"
                            """

                        } else {
                            echo "  Skipping ${service} (no changes)"
                        }
                    }
                }
            }
        }

        stage('Deploy API Gateway') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')

                    if (servicesToDeploy.contains('api-gateway')) {
                        def serviceVersionMap = new HashMap<>(new groovy.json.JsonSlurper().parseText(env.SERVICE_VERSION_MAP))
                        def version = serviceVersionMap['api-gateway'] ?: 'latest'
                        def imageTag = "${params.DOCKER_USER}/api-gateway:${version}"

                        echo " Deploying api-gateway (${imageTag})..."

                        // Single shell execution - let kubectl handle waiting
                        sh """
                            set -e
                            echo "Applying manifest for api-gateway..."
                            kubectl --insecure-skip-tls-verify apply -f infrastructure/kubernetes/base/api-gateway.yaml -n ${K8S_NAMESPACE}
                            
                            echo "Updating image for api-gateway..."
                            kubectl --insecure-skip-tls-verify set image deployment/api-gateway api-gateway=${imageTag} -n ${K8S_NAMESPACE}
                            
                            echo "Restarting deployment api-gateway..."
                            kubectl --insecure-skip-tls-verify rollout restart deployment/api-gateway -n ${K8S_NAMESPACE}
                            
                            echo "Waiting for api-gateway to be ready..."
                            kubectl --insecure-skip-tls-verify rollout status deployment/api-gateway -n ${K8S_NAMESPACE} --timeout=${env.SERVICE_READINESS_TIMEOUT}s
                            
                            echo "api-gateway deployed successfully"
                        """

                    } else {
                        echo "  Skipping api-gateway (no changes)"
                    }
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                script {
                    echo " Verifying final deployment state..."
                    sh """
                        echo "========================================="
                        echo "  Deployment Verification"
                        echo "========================================="

                        echo "Pods:"
                        kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} -o wide

                        echo ""
                        echo "Services:"
                        kubectl --insecure-skip-tls-verify get svc -n ${K8S_NAMESPACE}

                        echo ""
                        echo "Checking for pod issues..."
                        PROBLEM_PODS=\$(kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} --field-selector=status.phase!=Running,status.phase!=Succeeded --no-headers 2>/dev/null | wc -l)
                        if [ \$PROBLEM_PODS -gt 0 ]; then
                            echo "Warning: \$PROBLEM_PODS pod(s) not in Running state"
                            kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} --field-selector=status.phase!=Running,status.phase!=Succeeded
                        else
                            echo "All pods are running"
                        fi

                        echo ""
                        echo "Checking for duplicate pods..."
                        SERVICES=\$(echo "${ALL_SERVICES}" | tr ',' ' ')
                        for service in \$SERVICES; do
                            POD_COUNT=\$(kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} -l app=\$service --no-headers 2>/dev/null | wc -l)
                            if [ \$POD_COUNT -gt 1 ]; then
                                echo "Multiple pods found for \$service (\$POD_COUNT pods) - cleaning up..."
                                kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} -l app=\$service --sort-by=.metadata.creationTimestamp --no-headers | head -n -1 | awk '{print \$1}' | xargs -r kubectl --insecure-skip-tls-verify delete pod -n ${K8S_NAMESPACE} || true
                            fi
                        done

                        echo ""
                        echo "========================================="
                        echo "Verification complete"
                        echo "========================================="
                    """
                }
            }
        }

        stage('Get Access URL') {
            steps {
                script {
                    echo " Retrieving access URL..."
                    sh """
                        echo "========================================="
                        echo "  Access Information"
                        echo "========================================="

                        GATEWAY_URL=\$(kubectl --insecure-skip-tls-verify get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)

                        if [ -z "\$GATEWAY_URL" ]; then
                            if command -v minikube &> /dev/null; then
                                GATEWAY_URL=\$(minikube service api-gateway -n ${K8S_NAMESPACE} --url 2>/dev/null || echo "")
                            fi
                        fi

                        if [ -z "\$GATEWAY_URL" ]; then
                            NODE_PORT=\$(kubectl --insecure-skip-tls-verify get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null)
                            if [ -n "\$NODE_PORT" ]; then
                                NODE_IP=\$(kubectl --insecure-skip-tls-verify get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
                                GATEWAY_URL="http://\${NODE_IP}:\${NODE_PORT}"
                            fi
                        fi

                        if [ -n "\$GATEWAY_URL" ]; then
                            echo "API Gateway URL: \$GATEWAY_URL"
                            echo "Health Check: \$GATEWAY_URL/actuator/health"
                            echo "Eureka Dashboard: http://\$(kubectl --insecure-skip-tls-verify get svc service-discovery -n ${K8S_NAMESPACE} -o jsonpath='{.spec.clusterIP}'):8761"
                        else
                            echo "Could not determine external URL"
                            echo "Use: kubectl --insecure-skip-tls-verify port-forward -n ${K8S_NAMESPACE} svc/api-gateway 8080:80"
                        fi

                        echo "========================================="
                    """
                }
            }
        }

        stage('Wait for Services Ready') {
            when {
                expression { !params.SKIP_E2E_TESTS }
            }
            steps {
                script {
                    echo "â³ Waiting for all services to be ready..."
                    
                    sh """
                        set -e
                        
                        echo "========================================="
                        echo "Waiting for Pods to be Ready"
                        echo "========================================="
                        
                        # Wait for API Gateway
                        echo "Waiting for API Gateway..."
                        kubectl --insecure-skip-tls-verify wait --for=condition=ready pod -l app=api-gateway -n ${K8S_NAMESPACE} --timeout=300s || true
                        
                        # Wait for critical microservices
                        echo "Waiting for Product Service..."
                        kubectl --insecure-skip-tls-verify wait --for=condition=ready pod -l app=product-service -n ${K8S_NAMESPACE} --timeout=300s || true
                        
                        echo "Waiting for User Service..."
                        kubectl --insecure-skip-tls-verify wait --for=condition=ready pod -l app=user-service -n ${K8S_NAMESPACE} --timeout=300s || true
                        
                        echo "Waiting for Order Service..."
                        kubectl --insecure-skip-tls-verify wait --for=condition=ready pod -l app=order-service -n ${K8S_NAMESPACE} --timeout=300s || true
                        
                        echo ""
                        echo "Final pod status:"
                        kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE}
                        
                        echo ""
                        echo "âœ“ Services are ready for testing"
                        echo "========================================="
                    """
                }
            }
        }

        stage('Run E2E Tests') {
            when {
                expression { !params.SKIP_E2E_TESTS }
            }
            steps {
                script {
                    echo "ðŸ§ª Running E2E tests..."
                    
                    try {
                        sh """
                            set -e
                            
                            echo "========================================="
                            echo "Setting up Port-Forward to API Gateway"
                            echo "========================================="
                            
                            # Start kubectl port-forward in background
                            echo "Starting port-forward on port 18080..."
                            kubectl --insecure-skip-tls-verify port-forward -n ${K8S_NAMESPACE} svc/api-gateway 18080:80 > /tmp/port-forward.log 2>&1 &
                            PORT_FORWARD_PID=\$!
                            echo "Port-forward started with PID: \$PORT_FORWARD_PID"
                            
                            # Save PID to file for cleanup
                            echo \$PORT_FORWARD_PID > /tmp/port-forward.pid
                            
                            # Wait for port-forward to be ready
                            echo "Waiting for port-forward to be ready..."
                            sleep 5
                            
                            # Verify port-forward is still running
                            if ! ps -p \$PORT_FORWARD_PID > /dev/null; then
                                echo "âŒ Port-forward failed to start"
                                cat /tmp/port-forward.log
                                exit 1
                            fi
                            
                            GATEWAY_URL="http://localhost:18080"
                            echo "âœ“ Port-forward ready"
                            echo "API Gateway URL: \$GATEWAY_URL"
                            
                            # Test connectivity with retries
                            echo ""
                            echo "Testing connectivity..."
                            for i in 1 2 3 4 5; do
                                HTTP_CODE=\$(curl -s -o /dev/null -w "%{http_code}" \$GATEWAY_URL/app/api/products --max-time 5 || echo "000")
                                
                                if [ "\$HTTP_CODE" != "000" ]; then
                                    echo "âœ“ API Gateway is reachable (HTTP \$HTTP_CODE)"
                                    break
                                fi
                                
                                if [ \$i -lt 5 ]; then
                                    echo "Attempt \$i/5: Got \$HTTP_CODE, retrying in 5 seconds..."
                                    sleep 5
                                else
                                    echo "âŒ ERROR: Cannot reach API Gateway at \$GATEWAY_URL after 5 attempts"
                                    echo "HTTP Code: \$HTTP_CODE"
                                    echo ""
                                    echo "Port-forward logs:"
                                    cat /tmp/port-forward.log
                                    echo ""
                                    echo "API Gateway pods:"
                                    kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} -l app=api-gateway
                                    
                                    # Cleanup
                                    kill \$PORT_FORWARD_PID 2>/dev/null || true
                                    exit 1
                                fi
                            done
                            
                            echo ""
                            echo "========================================="
                            echo "Running Maven E2E Tests..."
                            echo "========================================="
                            
                            # Navigate to tests directory and run tests
                            cd tests
                            mvn clean verify \\
                                -Dtest.base.url="\$GATEWAY_URL" \\
                                -Dtest.timeout=60000 \\
                                -DfailIfNoTests=false
                            
                            echo ""
                            echo "========================================="
                            echo "âœ“ E2E Tests PASSED"
                            echo "========================================="
                            
                            # Cleanup port-forward
                            echo ""
                            echo "Stopping port-forward (PID: \$PORT_FORWARD_PID)..."
                            kill \$PORT_FORWARD_PID 2>/dev/null || true
                            rm -f /tmp/port-forward.pid /tmp/port-forward.log
                        """
                    } catch (Exception e) {
                        echo "  E2E tests failed: ${e.message}"
                        echo """
========================================
  E2E Tests Failed
========================================

You can run tests manually from WSL:
cd /mnt/c/Users/luism/OneDrive/Documents/ICESI/IngeSoftV/ecommerce-microservice-backend-app/tests
MINIKUBE_IP=\$(minikube ip)
mvn clean verify -Dtest.base.url="http://\$MINIKUBE_IP:32118"

========================================
"""
                        error("E2E tests failed: ${e.message}")
                    }
                }
            }
            post {
                always {
                    script {
                        // Cleanup port-forward if it's still running
                        sh '''
                            if [ -f /tmp/port-forward.pid ]; then
                                PID=$(cat /tmp/port-forward.pid)
                                echo "Cleaning up port-forward (PID: $PID)..."
                                kill $PID 2>/dev/null || true
                                rm -f /tmp/port-forward.pid /tmp/port-forward.log
                            fi
                        '''
                    }
                    junit allowEmptyResults: true, testResults: 'tests/target/failsafe-reports/*.xml'
                }
            }
        }

        stage('Deployment Summary') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def allServices = env.ALL_SERVICES.split(',')
                    def skippedServices = allServices - servicesToDeploy

                    echo """
========================================
  DEPLOYMENT SUMMARY
========================================
Namespace: ${K8S_NAMESPACE}
Docker Registry: ${params.DOCKER_USER}
Git Commit: ${env.GIT_COMMIT_SHORT}

Services Deployed (${servicesToDeploy.size()}):
${servicesToDeploy.collect { "  - ${it}" }.join('\n')}

Services Skipped (${skippedServices.size()}):
${skippedServices.collect { "  - ${it}" }.join('\n') ?: '  (none)'}

Next Steps:
1. Check pods: kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE}
2. Check logs: kubectl --insecure-skip-tls-verify logs -f -l app=<service> -n ${K8S_NAMESPACE}
3. Port forward: kubectl --insecure-skip-tls-verify port-forward -n ${K8S_NAMESPACE} svc/api-gateway 8080:80
========================================
                    """
                }
            }
        }
    }

    post {
        success {
            script {
                echo " DEPLOYMENT SUCCESS"
            }
        }
        failure {
            script {
                echo " DEPLOYMENT FAILED"
                echo "Collecting diagnostic information..."

                sh """
                    kubectl --insecure-skip-tls-verify get pods -n ${K8S_NAMESPACE} || true
                    kubectl --insecure-skip-tls-verify get events -n ${K8S_NAMESPACE} --sort-by=.firstTimestamp | tail -20 || true
                """
            }
        }
        always {
            archiveArtifacts artifacts: 'infrastructure/kubernetes/base/*.yaml', allowEmptyArchive: true
            deleteDir()
        }
    }
}