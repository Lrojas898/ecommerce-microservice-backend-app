pipeline {
    agent any

    parameters {
        string(name: 'SERVICE_VERSIONS', defaultValue: '{}', description: 'JSON string containing service-specific versions')
        string(name: 'DOCKER_USER', defaultValue: 'luisrojasc', description: 'Docker Hub username')
        booleanParam(name: 'SKIP_E2E_TESTS', defaultValue: false, description: 'Skip E2E tests to speed up deployment')
        booleanParam(name: 'FORCE_DEPLOY_ALL', defaultValue: false, description: 'Force deploy all services (ignore change detection)')
    }

    environment {
        // Kubernetes Configuration (LOCAL - PRODUCTION)
        K8S_NAMESPACE = 'prod'
        DOCKER_REGISTRY = 'docker.io'

        // Service Configuration
        ALL_SERVICES = 'service-discovery,user-service,product-service,order-service,payment-service,shipping-service,favourite-service,proxy-client,api-gateway'

        // Timeouts (increased for production)
        MAX_RETRY_COUNT = '5'
        SERVICE_READINESS_TIMEOUT = '300'
        POD_READY_TIMEOUT = '180'
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 60, unit: 'MINUTES')
        timestamps()
        disableConcurrentBuilds()
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "========================================="
                    echo "  E-Commerce Microservices Deploy (PROD)"
                    echo "  Environment: LOCAL (Minikube/K3s)"
                    echo "  Namespace: ${K8S_NAMESPACE}"
                    echo "  Docker User: ${params.DOCKER_USER}"
                    echo "========================================="
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                }
            }
        }

        stage('Configure kubectl') {
            steps {
                script {
                    echo " Configuring kubectl for local cluster..."
                    sh """
                        # Verify kubectl is configured
                        kubectl version --client

                        # Check cluster connectivity
                        kubectl cluster-info

                        # Set namespace
                        kubectl config set-context --current --namespace=${K8S_NAMESPACE}

                        echo "âœ“ kubectl configured successfully"
                    """
                }
            }
        }

        stage('Create Namespace') {
            steps {
                script {
                    echo " Ensuring namespace exists..."
                    sh """
                        kubectl get namespace ${K8S_NAMESPACE} || kubectl create namespace ${K8S_NAMESPACE}
                        kubectl get namespace ${K8S_NAMESPACE}
                    """
                }
            }
        }

        stage('Detect Services to Deploy') {
            steps {
                script {
                    def allServices = env.ALL_SERVICES.split(',')
                    def servicesToDeploy = []
                    def serviceVersionMap = [:]

                    if (params.FORCE_DEPLOY_ALL) {
                        echo "âš¡ FORCE_DEPLOY_ALL enabled - deploying all services"
                        servicesToDeploy = allServices as List
                        allServices.each { service ->
                            serviceVersionMap[service] = 'latest'
                        }
                    } else {
                        try {
                            def slurper = new groovy.json.JsonSlurper()
                            def parsed = slurper.parseText(params.SERVICE_VERSIONS)
                            serviceVersionMap = parsed.collectEntries { k, v -> [k.toString(), v.toString()] }

                            // Detect changed services (version != 'latest')
                            serviceVersionMap.each { service, version ->
                                if (version != 'latest' && allServices.contains(service)) {
                                    servicesToDeploy.add(service)
                                }
                            }

                            if (servicesToDeploy.isEmpty()) {
                                echo "  No changed services detected, deploying all as fallback"
                                servicesToDeploy = allServices as List
                                allServices.each { service ->
                                    if (!serviceVersionMap.containsKey(service)) {
                                        serviceVersionMap[service] = 'latest'
                                    }
                                }
                            }

                        } catch (Exception e) {
                            echo "  Failed to parse SERVICE_VERSIONS: ${e.message}"
                            echo "Deploying all services as fallback"
                            servicesToDeploy = allServices as List
                            allServices.each { service ->
                                serviceVersionMap[service] = 'latest'
                            }
                        }
                    }

                    env.SERVICES_TO_DEPLOY = servicesToDeploy.join(',')
                    env.SERVICE_VERSION_MAP = groovy.json.JsonOutput.toJson(serviceVersionMap)

                    echo "========================================="
                    echo "  Deployment Plan (PRODUCTION)"
                    echo "========================================="
                    echo "âœ“ Services to deploy (${servicesToDeploy.size()}): ${servicesToDeploy.join(', ')}"
                    echo "âœ“ Services to skip: ${(allServices - servicesToDeploy).join(', ') ?: 'none'}"
                    echo "âœ“ Version map: ${env.SERVICE_VERSION_MAP}"
                    echo "========================================="
                }
            }
        }

        stage('Manual Approval') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def deploymentSummary = """
========================================
  PRODUCTION DEPLOYMENT APPROVAL
========================================
Namespace: ${K8S_NAMESPACE}
Services to deploy: ${servicesToDeploy.join(', ')}
Docker User: ${params.DOCKER_USER}
Git Commit: ${env.GIT_COMMIT_SHORT}

  This will deploy to PRODUCTION environment!
========================================
                    """

                    echo deploymentSummary

                    timeout(time: 30, unit: 'MINUTES') {
                        input message: ' Approve deployment to PRODUCTION?',
                              ok: 'Deploy to Production',
                              submitter: 'admin,deployers',
                              parameters: [
                                  booleanParam(
                                      name: 'CONFIRM_PRODUCTION_DEPLOY',
                                      defaultValue: false,
                                      description: 'Check this box to confirm production deployment'
                                  )
                              ]
                    }

                    echo "âœ“ Production deployment approved"
                }
            }
        }

        stage('Cleanup Resources') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def persistentServices = ['postgresql', 'postgres']

                    echo "ðŸ§¹ Cleaning up resources for services to be deployed..."

                    servicesToDeploy.each { service ->
                        if (!persistentServices.contains(service)) {
                            echo ">>> Preparing ${service} for redeployment"
                            sh """
                                set -e

                                # Scale down to free resources
                                kubectl scale deployment/${service} --replicas=0 -n ${K8S_NAMESPACE} 2>/dev/null || echo "Deployment ${service} not found (first deploy)"

                                # Wait for pods to terminate
                                kubectl wait --for=delete pod -l app=${service} -n ${K8S_NAMESPACE} --timeout=60s 2>/dev/null || echo "No pods to delete for ${service}"

                                # Clean old replica sets (keep last 2)
                                kubectl get rs -n ${K8S_NAMESPACE} -l app=${service} --sort-by=.metadata.creationTimestamp -o name 2>/dev/null | head -n -2 | xargs -r kubectl delete -n ${K8S_NAMESPACE} || true

                                echo "âœ“ ${service} cleanup complete"
                            """
                        }
                    }
                }
            }
        }

        stage('Deploy Infrastructure Services') {
            steps {
                script {
                    def infraServices = ['service-discovery']
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def slurper = new groovy.json.JsonSlurper()
                    def serviceVersionMap = slurper.parseText(env.SERVICE_VERSION_MAP)

                    infraServices.each { service ->
                        if (servicesToDeploy.contains(service)) {
                            def version = serviceVersionMap[service] ?: 'latest'
                            def imageTag = "${params.DOCKER_USER}/${service}:${version}"

                            echo " Deploying ${service} (${imageTag})..."

                            sh label: "Deploy ${service}", script: """
                                set -e

                                # Apply base configuration
                                kubectl apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE}

                                # Update image
                                kubectl set image deployment/${service} ${service}=${imageTag} -n ${K8S_NAMESPACE}

                                # Scale up
                                kubectl scale deployment/${service} --replicas=1 -n ${K8S_NAMESPACE}

                                # Wait for rollout
                                kubectl rollout status deployment/${service} -n ${K8S_NAMESPACE} --timeout=${SERVICE_READINESS_TIMEOUT}s

                                # Wait for pod ready
                                kubectl wait --for=condition=ready pod -l app=${service} -n ${K8S_NAMESPACE} --timeout=${POD_READY_TIMEOUT}s

                                echo "âœ“ ${service} deployed successfully"
                            """

                            // Service-specific verification for Eureka
                            if (service == 'service-discovery') {
                                echo "Verifying Eureka is ready..."
                                sh """
                                    sleep 30
                                    retries=0
                                    until kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -sf http://localhost:8761/eureka/apps 2>/dev/null || [ \$retries -ge 3 ]; do
                                        echo "Waiting for Eureka... (attempt \$((retries + 1))/3)"
                                        sleep 20
                                        retries=\$((retries + 1))
                                    done
                                    echo "âœ“ Eureka is ready"
                                """
                            }
                        } else {
                            echo "  Skipping ${service} (no changes)"
                        }
                    }
                }
            }
        }

        stage('Deploy Microservices') {
            steps {
                script {
                    // Deployment order (dependencies first)
                    def deploymentOrder = [
                        'user-service',
                        'product-service',
                        'proxy-client',
                        'order-service',
                        'payment-service',
                        'shipping-service',
                        'favourite-service'
                    ]

                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def slurper = new groovy.json.JsonSlurper()
                    def serviceVersionMap = slurper.parseText(env.SERVICE_VERSION_MAP)

                    echo " Deploying microservices in order..."

                    deploymentOrder.each { service ->
                        if (servicesToDeploy.contains(service)) {
                            def version = serviceVersionMap[service] ?: 'latest'
                            def imageTag = "${params.DOCKER_USER}/${service}:${version}"

                            echo ">>> Deploying ${service} (${imageTag})..."

                            sh label: "Deploy ${service}", script: """
                                set -e

                                # Apply configuration
                                kubectl apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE}

                                # Update image
                                kubectl set image deployment/${service} ${service}=${imageTag} -n ${K8S_NAMESPACE}

                                # Scale up
                                kubectl scale deployment/${service} --replicas=1 -n ${K8S_NAMESPACE}

                                # Wait for rollout
                                kubectl rollout status deployment/${service} -n ${K8S_NAMESPACE} --timeout=${SERVICE_READINESS_TIMEOUT}s

                                # Wait for pod ready
                                kubectl wait --for=condition=ready pod -l app=${service} -n ${K8S_NAMESPACE} --timeout=${POD_READY_TIMEOUT}s

                                # Verify Eureka registration (if not proxy-client)
                                if [ "${service}" != "proxy-client" ]; then
                                    echo "Verifying ${service} registration with Eureka..."
                                    sleep 15
                                    retries=0
                                    SERVICE_NAME_UPPER=\$(echo "${service}" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
                                    until kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -sf http://localhost:8761/eureka/apps/\${SERVICE_NAME_UPPER} 2>/dev/null | grep -q "status" || [ \$retries -ge 3 ]; do
                                        echo "Waiting for Eureka registration... (attempt \$((retries + 1))/3)"
                                        sleep 10
                                        retries=\$((retries + 1))
                                    done
                                    if [ \$retries -lt 3 ]; then
                                        echo "âœ“ ${service} registered with Eureka"
                                    else
                                        echo "  ${service} may not be registered with Eureka (continuing anyway)"
                                    fi
                                fi

                                echo "âœ“ ${service} deployed successfully"
                            """
                        } else {
                            echo "  Skipping ${service} (no changes)"
                        }
                    }
                }
            }
        }

        stage('Deploy API Gateway') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')

                    if (servicesToDeploy.contains('api-gateway')) {
                        def slurper = new groovy.json.JsonSlurper()
                        def serviceVersionMap = slurper.parseText(env.SERVICE_VERSION_MAP)
                        def version = serviceVersionMap['api-gateway'] ?: 'latest'
                        def imageTag = "${params.DOCKER_USER}/api-gateway:${version}"

                        echo " Deploying api-gateway (${imageTag})..."

                        sh label: "Deploy API Gateway", script: """
                            set -e

                            kubectl apply -f infrastructure/kubernetes/base/api-gateway.yaml -n ${K8S_NAMESPACE}
                            kubectl set image deployment/api-gateway api-gateway=${imageTag} -n ${K8S_NAMESPACE}
                            kubectl scale deployment/api-gateway --replicas=1 -n ${K8S_NAMESPACE}
                            kubectl rollout status deployment/api-gateway -n ${K8S_NAMESPACE} --timeout=${SERVICE_READINESS_TIMEOUT}s

                            # Verify health
                            echo "Verifying API Gateway health..."
                            sleep 20
                            retries=0
                            until kubectl exec -n ${K8S_NAMESPACE} deploy/api-gateway -- curl -sf http://localhost:80/actuator/health 2>/dev/null || [ \$retries -ge 3 ]; do
                                echo "Waiting for API Gateway... (attempt \$((retries + 1))/3)"
                                sleep 15
                                retries=\$((retries + 1))
                            done

                            echo "âœ“ API Gateway deployed successfully"
                        """
                    } else {
                        echo "  Skipping api-gateway (no changes)"
                    }
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                script {
                    echo "ðŸ” Verifying final deployment state..."
                    sh """
                        echo "========================================="
                        echo "  Deployment Verification (PRODUCTION)"
                        echo "========================================="

                        # Show all pods
                        echo "Pods:"
                        kubectl get pods -n ${K8S_NAMESPACE} -o wide

                        # Show services
                        echo ""
                        echo "Services:"
                        kubectl get svc -n ${K8S_NAMESPACE}

                        # Check for issues
                        echo ""
                        echo "Checking for pod issues..."
                        PROBLEM_PODS=\$(kubectl get pods -n ${K8S_NAMESPACE} --field-selector=status.phase!=Running,status.phase!=Succeeded --no-headers 2>/dev/null | wc -l)
                        if [ \$PROBLEM_PODS -gt 0 ]; then
                            echo "  Warning: \$PROBLEM_PODS pod(s) not in Running state"
                            kubectl get pods -n ${K8S_NAMESPACE} --field-selector=status.phase!=Running,status.phase!=Succeeded
                        else
                            echo "âœ“ All pods are running"
                        fi

                        # Check for multiple pods per service
                        echo ""
                        echo "Checking for duplicate pods..."
                        SERVICES=\$(echo "${ALL_SERVICES}" | tr ',' ' ')
                        for service in \$SERVICES; do
                            POD_COUNT=\$(kubectl get pods -n ${K8S_NAMESPACE} -l app=\$service --no-headers 2>/dev/null | wc -l)
                            if [ \$POD_COUNT -gt 1 ]; then
                                echo "  Multiple pods found for \$service (\$POD_COUNT pods) - cleaning up..."
                                kubectl get pods -n ${K8S_NAMESPACE} -l app=\$service --sort-by=.metadata.creationTimestamp --no-headers | head -n -1 | awk '{print \$1}' | xargs -r kubectl delete pod -n ${K8S_NAMESPACE} || true
                            fi
                        done

                        echo ""
                        echo "========================================="
                        echo "âœ“ Verification complete"
                        echo "========================================="
                    """
                }
            }
        }

        stage('Get Access URL') {
            steps {
                script {
                    echo " Retrieving access URL..."
                    sh """
                        echo "========================================="
                        echo "  Access Information (PRODUCTION)"
                        echo "========================================="

                        # Get API Gateway URL (minikube or LoadBalancer)
                        GATEWAY_URL=\$(kubectl get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)

                        if [ -z "\$GATEWAY_URL" ]; then
                            # Try minikube service URL
                            if command -v minikube &> /dev/null; then
                                GATEWAY_URL=\$(minikube service api-gateway -n ${K8S_NAMESPACE} --url 2>/dev/null || echo "")
                            fi
                        fi

                        if [ -z "\$GATEWAY_URL" ]; then
                            # Get NodePort
                            NODE_PORT=\$(kubectl get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null)
                            if [ -n "\$NODE_PORT" ]; then
                                NODE_IP=\$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
                                GATEWAY_URL="http://\${NODE_IP}:\${NODE_PORT}"
                            fi
                        fi

                        if [ -n "\$GATEWAY_URL" ]; then
                            echo "âœ“ API Gateway URL: \$GATEWAY_URL"
                            echo "âœ“ Health Check: \$GATEWAY_URL/actuator/health"
                            echo "âœ“ Eureka Dashboard: http://\$(kubectl get svc service-discovery -n ${K8S_NAMESPACE} -o jsonpath='{.spec.clusterIP}'):8761"
                        else
                            echo "  Could not determine external URL"
                            echo "Use: kubectl port-forward -n ${K8S_NAMESPACE} svc/api-gateway 8080:80"
                        fi

                        echo "========================================="
                    """
                }
            }
        }

        stage('Run E2E Tests') {
            when {
                expression { !params.SKIP_E2E_TESTS }
            }
            steps {
                script {
                    echo " Running E2E tests..."

                    try {
                        sh """
                            # Wait for services to stabilize
                            echo "Waiting for services to stabilize (60s)..."
                            sleep 60

                            # Get API Gateway URL
                            GATEWAY_URL=\$(kubectl get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)

                            if [ -z "\$GATEWAY_URL" ]; then
                                if command -v minikube &> /dev/null; then
                                    GATEWAY_URL=\$(minikube service api-gateway -n ${K8S_NAMESPACE} --url 2>/dev/null | head -1)
                                fi
                            fi

                            if [ -z "\$GATEWAY_URL" ]; then
                                NODE_PORT=\$(kubectl get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.spec.ports[0].nodePort}')
                                NODE_IP=\$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
                                GATEWAY_URL="http://\${NODE_IP}:\${NODE_PORT}"
                            fi

                            echo "Testing against: \$GATEWAY_URL"

                            # Run E2E tests
                            cd tests
                            mvn clean verify -Pe2e-tests \\
                                -Dtest.base.url=\$GATEWAY_URL \\
                                -Dtest.timeout=60000 \\
                                -DfailIfNoTests=false
                        """
                    } catch (Exception e) {
                        echo "  E2E tests failed or could not run: ${e.message}"
                        error("E2E tests failed: ${e.message}")
                    }
                }
            }
            post {
                always {
                    junit allowEmptyResults: true, testResults: 'tests/target/failsafe-reports/*.xml'
                }
            }
        }

        stage('Deployment Summary') {
            steps {
                script {
                    def servicesToDeploy = env.SERVICES_TO_DEPLOY.split(',')
                    def allServices = env.ALL_SERVICES.split(',')
                    def skippedServices = allServices - servicesToDeploy

                    echo """
========================================
  DEPLOYMENT SUMMARY (PRODUCTION)
========================================
âœ“ Namespace: ${K8S_NAMESPACE}
âœ“ Docker Registry: ${params.DOCKER_USER}
âœ“ Git Commit: ${env.GIT_COMMIT_SHORT}

Services Deployed (${servicesToDeploy.size()}):
${servicesToDeploy.collect { "  â€¢ ${it}" }.join('\n')}

Services Skipped (${skippedServices.size()}):
${skippedServices.collect { "  â€¢ ${it}" }.join('\n') ?: '  (none)'}

Next Steps:
1. Check pods: kubectl get pods -n ${K8S_NAMESPACE}
2. Check logs: kubectl logs -f -l app=<service> -n ${K8S_NAMESPACE}
3. Port forward: kubectl port-forward -n ${K8S_NAMESPACE} svc/api-gateway 8080:80
========================================
                    """
                }
            }
        }
    }

    post {
        success {
            script {
                echo " DEPLOYMENT SUCCESS (PRODUCTION)"
            }
        }
        failure {
            script {
                echo " DEPLOYMENT FAILED (PRODUCTION)"
                echo "Collecting diagnostic information..."

                sh """
                    kubectl get pods -n ${K8S_NAMESPACE} || true
                    kubectl get events -n ${K8S_NAMESPACE} --sort-by=.firstTimestamp | tail -20 || true
                """
            }
        }
        always {
            // Archive deployment manifests
            archiveArtifacts artifacts: 'infrastructure/kubernetes/base/*.yaml', allowEmptyArchive: true

            // Cleanup
            deleteDir()
        }
    }
}
