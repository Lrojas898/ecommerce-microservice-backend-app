pipeline {
    agent any

    parameters {
        string(name: 'SERVICE_VERSIONS', defaultValue: '{}', description: 'JSON string containing service-specific versions')
    }

    environment {
        AWS_REGION = 'us-east-2'
        AWS_ACCOUNT_ID = '020951019497'
        ECR_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        K8S_CLUSTER = 'ecommerce-microservices-cluster'
        K8S_NAMESPACE = 'dev'
        ALL_SERVICES = 'service-discovery,cloud-config,user-service,product-service,order-service,payment-service,shipping-service,favourite-service,api-gateway'
        MAX_RETRY_COUNT = '3'
        SERVICE_READINESS_TIMEOUT = '300' // 5 minutes in seconds
    }

    stages {
        stage('Configure kubectl') {
            steps {
                sh """
                    aws eks update-kubeconfig --region ${AWS_REGION} --name ${K8S_CLUSTER}
                    kubectl config set-context --current --namespace=${K8S_NAMESPACE}
                """
            }
        }

        stage('Create Namespace') {
            steps {
                sh """
                    kubectl get namespace ${K8S_NAMESPACE} || kubectl create namespace ${K8S_NAMESPACE}
                """
            }
        }

        stage('Clean Old Pods') {
            steps {
                script {
                    echo "Scaling down old ReplicaSets to free memory for new deployments..."
                    def services = env.ALL_SERVICES.split(',')
                    services.each { service ->
                        sh """
                            # Get old replicasets (not the latest one)
                            OLD_RS=\$(kubectl get rs -n ${K8S_NAMESPACE} -l app=${service} --sort-by=.metadata.creationTimestamp -o name | head -n -1)

                            if [ ! -z "\$OLD_RS" ]; then
                                echo "Scaling down old ReplicaSets for ${service}..."
                                for rs in \$OLD_RS; do
                                    kubectl scale \$rs -n ${K8S_NAMESPACE} --replicas=0 || true
                                done
                            fi
                        """
                    }
                    echo "Old pods cleanup completed"
                }
            }
        }

        stage('Deploy Infrastructure Services') {
            steps {
                script {
                    // Deploy and verify core infrastructure services first
                    def infraServices = ['service-discovery', 'cloud-config']
                    def serviceVersions
                    try {
                        serviceVersions = readJSON text: params.SERVICE_VERSIONS
                    } catch (Exception e) {
                        echo "Warning: Failed to parse SERVICE_VERSIONS JSON. Using latest for all services."
                        serviceVersions = [:]
                    }
                    
                    infraServices.each { service ->
                        echo "Deploying ${service}..."
                        def version = serviceVersions[service] ?: 'latest'
                        
                        sh """
                            kubectl apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE}
                            kubectl set image deployment/${service} ${service}=${ECR_REGISTRY}/ecommerce/${service}:${version} -n ${K8S_NAMESPACE}
                            kubectl rollout restart deployment/${service} -n ${K8S_NAMESPACE}
                        """
                        
                        // Wait for deployment to be ready with retries
                        def ready = false
                        def retryCount = 0
                        
                        while (!ready && retryCount < env.MAX_RETRY_COUNT.toInteger()) {
                            try {
                                sh """
                                    kubectl rollout status deployment/${service} -n ${K8S_NAMESPACE} --timeout=${env.SERVICE_READINESS_TIMEOUT}s
                                    if [ "${service}" = "service-discovery" ]; then
                                        # Wait for Eureka to be ready
                                        echo "Waiting for Eureka to be fully ready..."
                                        sleep 60
                                        # Verify Eureka is responding
                                        kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -s --retry 5 --retry-delay 10 http://localhost:8761/eureka/apps
                                    elif [ "${service}" = "cloud-config" ]; then
                                        # Wait for Config Server
                                        echo "Waiting for Config Server to be fully ready..."
                                        sleep 45
                                        # Verify Config Server is responding
                                        kubectl exec -n ${K8S_NAMESPACE} deploy/cloud-config -- curl -s --retry 5 --retry-delay 10 http://localhost:8888/actuator/health
                                    fi
                                """
                                ready = true
                            } catch (Exception e) {
                                retryCount++
                                echo "Attempt ${retryCount}/${env.MAX_RETRY_COUNT} failed for ${service}. Retrying..."
                                if (retryCount >= env.MAX_RETRY_COUNT.toInteger()) {
                                    error "Failed to deploy ${service} after ${env.MAX_RETRY_COUNT} attempts"
                                }
                                sleep 30
                            }
                        }
                    }
                }
            }
        }

        stage('Deploy Microservices') {
            steps {
                script {
                    def microservices = [
                        'user-service',
                        'product-service',
                        'order-service',
                        'favourite-service',
                        'payment-service',
                        'shipping-service'
                    ]

                    microservices.each { service ->
                        echo "Deploying ${service}..."
                        
                        def version = 'latest'
                        try {
                            version = serviceVersions[service] ?: 'latest'
                        } catch (Exception e) {
                            echo "Warning: Could not get version for ${service}, using latest"
                        }
                        sh """
                            kubectl apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE}
                            kubectl set image deployment/${service} ${service}=${ECR_REGISTRY}/ecommerce/${service}:${version} -n ${K8S_NAMESPACE}
                            kubectl rollout restart deployment/${service} -n ${K8S_NAMESPACE}
                        """
                        
                        // Wait for deployment with retries
                        def ready = false
                        def retryCount = 0
                        
                        while (!ready && retryCount < env.MAX_RETRY_COUNT.toInteger()) {
                            try {
                                sh """
                                    kubectl rollout status deployment/${service} -n ${K8S_NAMESPACE} --timeout=${env.SERVICE_READINESS_TIMEOUT}s
                                    # Verify service registered with Eureka
                                    echo "Verifying ${service} registration with Eureka..."
                                    kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -s --retry 5 --retry-delay 10 http://localhost:8761/eureka/apps/${service.toUpperCase()} | grep "status"
                                """
                                ready = true
                            } catch (Exception e) {
                                retryCount++
                                echo "Attempt ${retryCount}/${env.MAX_RETRY_COUNT} failed for ${service}. Retrying..."
                                if (retryCount >= env.MAX_RETRY_COUNT.toInteger()) {
                                    error "Failed to deploy ${service} after ${env.MAX_RETRY_COUNT} attempts"
                                }
                                sleep 30
                            }
                        }
                    }
                }
            }
        }

        stage('Deploy API Gateway') {
            steps {
                script {
                    echo "Deploying api-gateway..."
                    
                    def version = serviceVersions['api-gateway'] ?: 'latest'
                    sh """
                        kubectl apply -f infrastructure/kubernetes/base/api-gateway.yaml -n ${K8S_NAMESPACE}
                        kubectl set image deployment/api-gateway api-gateway=${ECR_REGISTRY}/ecommerce/api-gateway:${version} -n ${K8S_NAMESPACE}
                        kubectl rollout restart deployment/api-gateway -n ${K8S_NAMESPACE}
                    """
                    
                    // Wait for deployment with retries
                    def ready = false
                    def retryCount = 0
                    
                    while (!ready && retryCount < env.MAX_RETRY_COUNT.toInteger()) {
                        try {
                            sh """
                                kubectl rollout status deployment/api-gateway -n ${K8S_NAMESPACE} --timeout=${env.SERVICE_READINESS_TIMEOUT}s
                                # Verify API Gateway registration
                                echo "Verifying API Gateway registration with Eureka..."
                                kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -s --retry 5 --retry-delay 10 http://localhost:8761/eureka/apps/API-GATEWAY | grep "status"
                            """
                            ready = true
                        } catch (Exception e) {
                            retryCount++
                            echo "Attempt ${retryCount}/${env.MAX_RETRY_COUNT} failed for api-gateway. Retrying..."
                            if (retryCount >= env.MAX_RETRY_COUNT.toInteger()) {
                                error "Failed to deploy api-gateway after ${env.MAX_RETRY_COUNT} attempts"
                            }
                            sleep 30
                        }
                    }
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                sh """
                    echo "=== Pods Status ==="
                    kubectl get pods -n ${K8S_NAMESPACE}
                    echo ""
                    echo "=== Services ==="
                    kubectl get svc -n ${K8S_NAMESPACE}
                """
            }
        }

        stage('E2E Tests') {
            steps {
                script {
                    def gatewayUrl = sh(
                        script: "kubectl get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo 'localhost'",
                        returnStdout: true
                    ).trim()

                    if (gatewayUrl && gatewayUrl != 'localhost') {
                        echo "Running E2E tests against: http://${gatewayUrl}/app"
                        echo "Waiting 300 seconds for all services to register with Eureka and be fully ready..."
                        sleep 300

                        // Verify all services are registered with Eureka
                        sh """
                            echo "Verifying service registration status..."
                            kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -s http://localhost:8761/eureka/apps | grep "status" || true
                        """

                        sh """
                            cd tests
                            mvn clean verify -Pe2e-tests \\
                                -Dtest.base.url=http://${gatewayUrl}/app \\
                                -Dtest.timeout=60000
                        """
                    } else {
                        echo "API Gateway not accessible externally, skipping E2E tests"
                    }
                }
            }
            post {
                always {
                    junit allowEmptyResults: true, testResults: 'tests/target/failsafe-reports/*.xml'
                }
            }
        }

        stage('Performance Tests') {
            steps {
                script {
                    def gatewayUrl = sh(
                        script: "kubectl get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo ''",
                        returnStdout: true
                    ).trim()

                    if (gatewayUrl) {
                        sh """
                            cd tests/performance
                            python3 -m pip install locust --quiet || true
                            locust -f locustfile.py --host=http://${gatewayUrl} \\
                                   --users 10 --spawn-rate 2 --run-time 60s --headless \\
                                   --html reports/performance_report.html || echo "Performance tests failed or not configured"
                        """
                    } else {
                        echo "API Gateway not accessible, skipping performance tests"
                    }
                }
            }
            post {
                always {
                    publishHTML([
                        allowMissing: true,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'tests/performance/reports',
                        reportFiles: 'performance_report.html',
                        reportName: 'Performance Test Reports'
                    ])
                }
            }
        }
    }

    post {
        success {
            script {
                echo "DEV DEPLOYMENT SUCCESS: ${env.ALL_SERVICES}"
                echo "Image tag: ${params.IMAGE_TAG}"
                echo "Namespace: ${K8S_NAMESPACE}"
                echo "Cluster: ${K8S_CLUSTER}"
            }
        }
        failure {
            script {
                echo "DEV DEPLOYMENT FAILED"
                echo "Services affected: ${env.ALL_SERVICES}"
                echo "Attempting rollback..."

                def services = env.ALL_SERVICES.split(',')
                services.each { service ->
                    sh "kubectl rollout undo deployment/${service} -n ${K8S_NAMESPACE} || echo 'Rollback failed for ${service}'"
                }
            }
        }
        always {
            deleteDir()
        }
    }
}
