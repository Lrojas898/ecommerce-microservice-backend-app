pipeline {
    agent any

    parameters {
        string(name: 'SERVICE_VERSIONS', defaultValue: '{}', description: 'JSON string containing service-specific versions')
    }

    environment {
        AWS_REGION = 'us-east-2'
        AWS_ACCOUNT_ID = '020951019497'
        ECR_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        K8S_CLUSTER = 'ecommerce-microservices-cluster'
        K8S_NAMESPACE = 'dev'
        ALL_SERVICES = 'service-discovery,cloud-config,user-service,product-service,order-service,payment-service,shipping-service,favourite-service,proxy-client,api-gateway'
        MAX_RETRY_COUNT = '5'
        SERVICE_READINESS_TIMEOUT = '900'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Configure kubectl') {
            steps {
                sh """
                    set -e
                    aws eks update-kubeconfig --region ${AWS_REGION} --name ${K8S_CLUSTER}
                    kubectl config set-context --current --namespace=${K8S_NAMESPACE}
                """
            }
        }

        stage('Create Namespace') {
            steps {
                sh """
                    kubectl get namespace ${K8S_NAMESPACE} || kubectl create namespace ${K8S_NAMESPACE}
                """
            }
        }

        stage('Setup RDS Database Configuration') {
            steps {
                script {
                    echo "Configuring PostgreSQL RDS connections for all microservices..."
                    
                    // Define microservices that need database connections
                    def microservicesWithDb = [
                        'user': 'user-service',
                        'product': 'product-service', 
                        'order': 'order-service',
                        'payment': 'payment-service',
                        'favourite': 'favourite-service'
                    ]
                    
                    microservicesWithDb.each { dbKey, serviceName ->
                        try {
                            echo "Configuring PostgreSQL RDS for ${serviceName}..."
                            
                            // Get RDS credentials from AWS Secrets Manager
                            def rdsSecretArn = "ecommerce-microservices-${dbKey}-postgres-credentials"
                            def rdsCredentials = sh(
                                script: """
                                    aws secretsmanager get-secret-value --region ${AWS_REGION} --secret-id ${rdsSecretArn} --query SecretString --output text
                                """,
                                returnStdout: true
                            ).trim()
                            
                            def rdsJson = readJSON text: rdsCredentials
                            
                            // Create Kubernetes secret with RDS credentials for each service
                            sh """
                                kubectl create secret generic ${serviceName}-postgres-secret -n ${K8S_NAMESPACE} \\
                                  --from-literal=POSTGRES_HOST='${rdsJson.host}' \\
                                  --from-literal=POSTGRES_PORT='${rdsJson.port}' \\
                                  --from-literal=POSTGRES_DB='${rdsJson.dbname}' \\
                                  --from-literal=POSTGRES_USERNAME='${rdsJson.username}' \\
                                  --from-literal=POSTGRES_PASSWORD='${rdsJson.password}' \\
                                  --from-literal=POSTGRES_URL='${rdsJson.url}' \\
                                  --dry-run=client -o yaml | kubectl apply -f -
                            """
                            
                            echo "PostgreSQL RDS credentials configured successfully for ${serviceName}"
                            
                        } catch (Exception e) {
                            echo "Warning: Failed to configure RDS for ${serviceName}: ${e.getMessage()}"
                            echo "Service ${serviceName} will fall back to local H2 database"
                        }
                    }
                    
                    // Legacy secret for backward compatibility (user-service)
                    try {
                        def legacySecretArn = "ecommerce-microservices-postgres-credentials"
                        def legacyCredentials = sh(
                            script: """
                                aws secretsmanager get-secret-value --region ${AWS_REGION} --secret-id ${legacySecretArn} --query SecretString --output text
                            """,
                            returnStdout: true
                        ).trim()
                        
                        def legacyJson = readJSON text: legacyCredentials
                        
                        sh """
                            kubectl create secret generic postgres-secret -n ${K8S_NAMESPACE} \\
                              --from-literal=POSTGRES_HOST='${legacyJson.host}' \\
                              --from-literal=POSTGRES_PORT='${legacyJson.port}' \\
                              --from-literal=POSTGRES_DB='${legacyJson.dbname}' \\
                              --from-literal=POSTGRES_USERNAME='${legacyJson.username}' \\
                              --from-literal=POSTGRES_PASSWORD='${legacyJson.password}' \\
                              --dry-run=client -o yaml | kubectl apply -f -
                        """
                        
                        echo "Legacy PostgreSQL secret configured for backward compatibility"
                        
                    } catch (Exception e) {
                        echo "Warning: Failed to configure legacy PostgreSQL secret: ${e.getMessage()}"
                    }
                }
            }
        }

        stage('Deploy PostgreSQL (if using local)') {
            when {
                // Only deploy local PostgreSQL if RDS is not available or in fallback mode
                expression { 
                    env.USE_LOCAL_POSTGRES == 'true' || 
                    sh(script: "aws secretsmanager get-secret-value --region ${AWS_REGION} --secret-id ecommerce-microservices-postgres-credentials --query SecretString --output text", returnStatus: true) != 0
                }
            }
            steps {
                script {
                    echo "Deploying local PostgreSQL as fallback..."
                    sh """
                        # Deploy PostgreSQL if not already running
                        if ! kubectl get deployment postgresql -n ${K8S_NAMESPACE} &>/dev/null; then
                            echo "PostgreSQL deployment not found, creating..."
                            kubectl apply -f infrastructure/kubernetes/postgres-deployment.yaml
                        else
                            echo "PostgreSQL already deployed, checking status..."
                            kubectl get pods -l app=postgresql -n ${K8S_NAMESPACE}
                        fi
                        
                        # Wait for PostgreSQL to be ready
                        echo "Waiting for PostgreSQL to be ready..."
                        kubectl rollout status deployment/postgresql -n ${K8S_NAMESPACE} --timeout=300s
                    """
                }
            }
        }

        stage('Clean Old Pods') {
            steps {
                script {
                    def persistentServices = ['postgresql', 'postgres', 'service-discovery', 'cloud-config']
                    def servicesToClean = []

                    // Parse SERVICE_VERSIONS to identify changed services
                    try {
                        def slurper = new groovy.json.JsonSlurper()
                        def parsed = slurper.parseText(params.SERVICE_VERSIONS)
                        def serviceVersions = parsed.collectEntries { k, v -> [k.toString(), v.toString()] }

                        serviceVersions.each { service, version ->
                            if (version != 'latest' && !persistentServices.contains(service)) {
                                servicesToClean.add(service)
                            }
                        }

                        echo "=== SELECTIVE POD CLEANUP ==="
                        echo "Services to clean: ${servicesToClean}"
                        echo "Services to skip: ${persistentServices}"

                    } catch (Exception e) {
                        echo "Warning: Could not parse SERVICE_VERSIONS, cleaning all services"
                        servicesToClean = env.ALL_SERVICES.split(',').findAll { !persistentServices.contains(it) }
                    }

                    // Clean only pods that will be redeployed
                    servicesToClean.each { service ->
                        echo ">>> Cleaning pods for ${service} (will be redeployed)"
                        sh """
                            set -e
                            echo "Pre-deployment cleanup for ${service}..."

                            # Scale down deployment to 0 to free resources
                            echo "Scaling down ${service} to free resources..."
                            kubectl scale deployment/${service} -n ${K8S_NAMESPACE} --replicas=0 || echo "Deployment ${service} not found"

                            # Wait for pods to terminate
                            echo "Waiting for pods to terminate..."
                            kubectl wait --for=delete pods -l app=${service} -n ${K8S_NAMESPACE} --timeout=60s || echo "Some pods may still be terminating"

                            # Delete old replica sets with 0 replicas
                            echo "Checking for old replica sets..."
                            kubectl get rs -n ${K8S_NAMESPACE} -l app=${service} -o name 2>/dev/null | while read rs; do
                                if [ -n "\$rs" ]; then
                                    DESIRED=\$(kubectl get \$rs -n ${K8S_NAMESPACE} -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "")
                                    if [ "\$DESIRED" = "0" ]; then
                                        echo "Deleting old replica set: \$rs"
                                        kubectl delete \$rs -n ${K8S_NAMESPACE} || echo "Failed to delete \$rs"
                                    fi
                                fi
                            done

                            # Clean up any pods in terminating state
                            echo "Cleaning up stuck terminating pods..."
                            kubectl get pods -n ${K8S_NAMESPACE} -l app=${service} --field-selector=status.phase=Terminating -o name 2>/dev/null | while read pod; do
                                if [ -n "\$pod" ]; then
                                    echo "Force deleting stuck pod: \$pod"
                                    kubectl delete \$pod -n ${K8S_NAMESPACE} --grace-period=0 --force || echo "Failed to force delete \$pod"
                                fi
                            done

                            echo "Cleanup completed for ${service}"
                        """
                    }
                }
            }
        }

        stage('Deploy Infrastructure Services') {
            steps {
                script {
                    def infraServices = ['service-discovery', 'cloud-config']
                    def serviceVersions = [:]
                    try {
                        def slurper = new groovy.json.JsonSlurper()
                        def parsed = slurper.parseText(params.SERVICE_VERSIONS)
                        serviceVersions = parsed.collectEntries { k, v -> [k.toString(), v.toString()] }
                    } catch (Exception e) {
                        echo "Warning: Failed to parse SERVICE_VERSIONS JSON. Using latest for all services."
                    }

                    infraServices.each { service ->
                        def version = serviceVersions[service] ?: 'latest'
                        sh label: "Deploy ${service}", script: """
                            set -e

                            echo ">>> Step 1: Scale down ${service} to free resources"
                            kubectl scale deployment/${service} --replicas=0 -n ${K8S_NAMESPACE} || true
                            kubectl wait --for=delete pod -l app=${service} -n ${K8S_NAMESPACE} --timeout=60s || true

                            echo ">>> Step 2: Apply configuration and update image"
                            kubectl apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE}
                            kubectl set image deployment/${service} ${service}=${ECR_REGISTRY}/ecommerce/${service}:${version} -n ${K8S_NAMESPACE}

                            echo ">>> Step 3: Scale up ${service} with new image"
                            kubectl scale deployment/${service} --replicas=1 -n ${K8S_NAMESPACE}
                            kubectl rollout status deployment/${service} -n ${K8S_NAMESPACE} --timeout=${SERVICE_READINESS_TIMEOUT}s

                            echo ">>> Step 4: Verify pod is running"
                            kubectl wait --for=condition=ready pod -l app=${service} -n ${K8S_NAMESPACE} --timeout=300s

                            if [ "${service}" = "service-discovery" ]; then
                                echo ">>> Step 5: Verify Eureka is ready"
                                sleep 60
                                retries=0
                                until kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -sf http://localhost:8761/eureka/apps || [ \$retries -ge ${MAX_RETRY_COUNT} ]; do
                                    echo "Waiting for Eureka to be ready (attempt \$((retries + 1))/${MAX_RETRY_COUNT})..."
                                    sleep 30
                                    retries=\$((retries + 1))
                                done
                                if [ \$retries -ge ${MAX_RETRY_COUNT} ]; then
                                    echo "ERROR: Eureka health check failed after \${MAX_RETRY_COUNT} attempts"
                                    exit 1
                                fi
                                echo ">>> Eureka is ready and accepting registrations"
                            elif [ "${service}" = "cloud-config" ]; then
                                echo ">>> Step 5: Verify Config Server is ready"
                                sleep 45
                                retries=0
                                until kubectl exec -n ${K8S_NAMESPACE} deploy/cloud-config -- curl -sf http://localhost:9296/actuator/health || [ \$retries -ge ${MAX_RETRY_COUNT} ]; do
                                    echo "Waiting for Config Server to be ready (attempt \$((retries + 1))/${MAX_RETRY_COUNT})..."
                                    sleep 30
                                    retries=\$((retries + 1))
                                done
                                if [ \$retries -ge ${MAX_RETRY_COUNT} ]; then
                                    echo "ERROR: Config Server health check failed after \${MAX_RETRY_COUNT} attempts"
                                    exit 1
                                fi
                                echo ">>> Config Server is ready and serving configurations"
                            fi

                            echo ">>> ${service} deployed successfully!"
                        """
                    }
                }
            }
        }

        stage('Deploy Microservices') {
            steps {
                script {
                    // Define deployment order
                    def microservices = [
                        'proxy-client',
                        'shipping-service',
                        'user-service',
                        'product-service',
                        'order-service',
                        'favourite-service',
                        'payment-service'
                    ]

                    // Parse service versions from build pipeline
                    def serviceVersions = [:]
                    def changedServices = []

                    try {
                        def slurper = new groovy.json.JsonSlurper()
                        def parsed = slurper.parseText(params.SERVICE_VERSIONS)
                        serviceVersions = parsed.collectEntries { k, v -> [k.toString(), v.toString()] }

                        // Detect which services actually changed (version != 'latest')
                        serviceVersions.each { service, version ->
                            if (version != 'latest' && microservices.contains(service)) {
                                changedServices.add(service)
                            }
                        }

                        echo "=== SELECTIVE DEPLOYMENT ==="
                        echo "All service versions: ${serviceVersions}"
                        echo "Changed services to deploy: ${changedServices}"
                        echo "Services to skip: ${microservices - changedServices}"

                    } catch (Exception e) {
                        echo "Warning: Could not parse SERVICE_VERSIONS, deploying all services"
                        echo "Error: ${e.getMessage()}"
                        changedServices = microservices
                    }

                    // If no services changed, deploy all (safety fallback)
                    if (changedServices.isEmpty()) {
                        echo "No changed services detected, deploying all services as safety fallback"
                        changedServices = microservices
                    }

                    // Deploy only changed services
                    microservices.each { service ->
                        if (changedServices.contains(service)) {
                            def version = serviceVersions[service] ?: 'latest'
                            echo ">>> Deploying ${service} with version ${version} (CHANGED)"

                            sh label: "Deploy ${service}", script: """
                                set -e

                                echo ">>> Step 1: Scale down ${service} to free resources"
                                kubectl scale deployment/${service} --replicas=0 -n ${K8S_NAMESPACE} || true
                                kubectl wait --for=delete pod -l app=${service} -n ${K8S_NAMESPACE} --timeout=60s || true

                                echo ">>> Step 2: Apply configuration and update image"
                                kubectl apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE}
                                kubectl set image deployment/${service} ${service}=${ECR_REGISTRY}/ecommerce/${service}:${version} -n ${K8S_NAMESPACE}

                                echo ">>> Step 3: Scale up ${service} with new image"
                                kubectl scale deployment/${service} --replicas=1 -n ${K8S_NAMESPACE}
                                kubectl rollout status deployment/${service} -n ${K8S_NAMESPACE} --timeout=${SERVICE_READINESS_TIMEOUT}s

                                echo ">>> Step 4: Verify pod is running"
                                kubectl wait --for=condition=ready pod -l app=${service} -n ${K8S_NAMESPACE} --timeout=300s

                                echo ">>> Step 5: Verify Eureka registration"
                                sleep 30
                                retries=0
                                until kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -sf http://localhost:8761/eureka/apps/${service.toUpperCase()} | grep -q "status" || [ \$retries -ge ${MAX_RETRY_COUNT} ]; do
                                    echo "Waiting for ${service} to register with Eureka (attempt \$((retries + 1))/${MAX_RETRY_COUNT})..."
                                    sleep 30
                                    retries=\$((retries + 1))
                                done
                                if [ \$retries -ge ${MAX_RETRY_COUNT} ]; then
                                    echo "ERROR: Eureka registration check failed for ${service} after \${MAX_RETRY_COUNT} attempts"
                                    exit 1
                                fi

                                echo ">>> ${service} deployed successfully!"
                            """
                        } else {
                            def currentVersion = serviceVersions[service] ?: 'latest'
                            echo ">>> Skipping ${service} (version ${currentVersion} - NO CHANGES)"
                        }
                    }

                    echo "=== DEPLOYMENT SUMMARY ==="
                    echo "Deployed: ${changedServices.join(', ')}"
                    echo "Skipped: ${(microservices - changedServices).join(', ')}"
                }
            }
        }

        stage('Deploy API Gateway') {
            steps {
                script {
                    def serviceVersions = [:]
                    def version = 'latest'
                    def shouldDeploy = false

                    try {
                        def slurper = new groovy.json.JsonSlurper()
                        def parsed = slurper.parseText(params.SERVICE_VERSIONS)
                        serviceVersions = parsed.collectEntries { k, v -> [k.toString(), v.toString()] }
                        version = serviceVersions['api-gateway'] ?: 'latest'

                        // Deploy if version changed or as fallback
                        shouldDeploy = (version != 'latest')
                    } catch (Exception e) {
                        echo "Warning: Could not parse SERVICE_VERSIONS"
                        shouldDeploy = true // Deploy on error as safety
                    }

                    if (shouldDeploy) {
                        echo ">>> Deploying api-gateway with version ${version} (CHANGED)"
                        sh label: "Deploy api-gateway", script: """
                            set -e
                            kubectl apply -f infrastructure/kubernetes/base/api-gateway.yaml -n ${K8S_NAMESPACE}
                            kubectl set image deployment/api-gateway api-gateway=${ECR_REGISTRY}/ecommerce/api-gateway:${version} -n ${K8S_NAMESPACE}
                            kubectl rollout restart deployment/api-gateway -n ${K8S_NAMESPACE}
                            kubectl rollout status deployment/api-gateway -n ${K8S_NAMESPACE} --timeout=${SERVICE_READINESS_TIMEOUT}s

                            retries=0
                            until kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -sf http://localhost:8761/eureka/apps/API-GATEWAY | grep -q "status" || [ \$retries -ge ${MAX_RETRY_COUNT} ]; do
                                sleep 30
                                retries=\$((retries + 1))
                            done
                            if [ \$retries -ge ${MAX_RETRY_COUNT} ]; then
                                echo "Eureka registration check failed for api-gateway after \${MAX_RETRY_COUNT} attempts"
                                exit 1
                            fi

                            # Verify API Gateway health
                            echo "Verifying API Gateway health..."
                            retries=0
                            until kubectl exec -n ${K8S_NAMESPACE} deploy/api-gateway -- curl -sf http://localhost:80/actuator/health || [ \$retries -ge ${MAX_RETRY_COUNT} ]; do
                                sleep 30
                                retries=\$((retries + 1))
                            done
                            if [ \$retries -ge ${MAX_RETRY_COUNT} ]; then
                                echo "API Gateway health check failed after \${MAX_RETRY_COUNT} attempts"
                                exit 1
                            fi
                        """
                    } else {
                        echo ">>> Skipping api-gateway (version ${version} - NO CHANGES)"
                    }
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                sh """
                    echo "Final deployment verification..."
                    kubectl get pods -n ${K8S_NAMESPACE}
                    kubectl get svc -n ${K8S_NAMESPACE}
                    
                    # Check for multiple pods per service and clean up if necessary
                    echo "Checking for multiple pods per service..."
                    SERVICES=\$(echo "${ALL_SERVICES}" | tr ',' ' ')
                    for service in \$SERVICES; do
                        pod_count=\$(kubectl get pods -n ${K8S_NAMESPACE} -l app=\$service --no-headers | wc -l)
                        if [ \$pod_count -gt 1 ]; then
                            echo "WARNING: Multiple pods found for \$service (\$pod_count pods)"
                            # Keep only the newest pod - fixed syntax
                            kubectl get pods -n ${K8S_NAMESPACE} -l app=\$service --sort-by=.metadata.creationTimestamp --no-headers | head -n -1 | awk '{print \$1}' > /tmp/pods_to_delete
                            while read pod_name; do
                                if [ -n "\$pod_name" ]; then
                                    echo "Deleting old pod: \$pod_name"
                                    kubectl delete pod "\$pod_name" -n ${K8S_NAMESPACE} || echo "Failed to delete \$pod_name"
                                fi
                            done < /tmp/pods_to_delete
                            rm -f /tmp/pods_to_delete
                        fi
                    done
                    
                    echo "Final pod status:"
                    kubectl get pods -n ${K8S_NAMESPACE}
                """
            }
        }

        stage('Post-Deployment Cleanup') {
            steps {
                script {
                    def services = env.ALL_SERVICES.split(',')
                    services.each { service ->
                        sh """
                            set -e
                            echo "Post-deployment cleanup for ${service}..."
                            
                            # Get all replica sets for this service, sorted by creation time (oldest first)
                            OLD_RS=\$(kubectl get rs -n ${K8S_NAMESPACE} -l app=${service} --sort-by=.metadata.creationTimestamp -o name | head -n -1)
                            
                            if [ ! -z "\$OLD_RS" ]; then
                                echo "Cleaning up old replica sets for ${service}:"
                                for rs in \$OLD_RS; do
                                    DESIRED=\$(kubectl get \$rs -n ${K8S_NAMESPACE} -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")
                                    CURRENT=\$(kubectl get \$rs -n ${K8S_NAMESPACE} -o jsonpath='{.status.replicas}' 2>/dev/null || echo "0")
                                    echo "  Replica set \$rs - Desired: \$DESIRED, Current: \$CURRENT"
                                    
                                    # Scale down and delete old replica sets
                                    if [ "\$DESIRED" = "0" ] || [ "\$CURRENT" = "0" ]; then
                                        echo "  Deleting old replica set: \$rs"
                                        kubectl delete \$rs -n ${K8S_NAMESPACE} --ignore-not-found=true || true
                                    fi
                                done
                            fi
                            
                            # Ensure deployment has exactly 1 replica running
                            CURRENT_REPLICAS=\$(kubectl get deployment ${service} -n ${K8S_NAMESPACE} -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
                            if [ "\$CURRENT_REPLICAS" != "1" ]; then
                                echo "Warning: ${service} has \$CURRENT_REPLICAS ready replicas, expected 1"
                            fi
                        """
                    }
                    
                    // Final cleanup summary
                    sh """
                        echo "=== Final Cluster State ==="
                        echo "Active pods:"
                        kubectl get pods -n ${K8S_NAMESPACE}
                        echo ""
                        echo "Active replica sets:"
                        kubectl get rs -n ${K8S_NAMESPACE} | grep -v "0         0         0"
                    """
                }
            }
        }

        stage('E2E Tests') {
            steps {
                script {
                    def gatewayUrl = sh(
                        script: "kubectl get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo 'localhost'",
                        returnStdout: true
                    ).trim()

                    if (gatewayUrl && gatewayUrl != 'localhost') {
                        sh """
                            set -e
                            echo "Waiting for services to stabilize before running E2E tests..."
                            sleep 600
                            
                            # Verify all services are registered in Eureka
                            echo "Verifying service registration..."
                            kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -sf http://localhost:8761/eureka/apps | grep -q "USER-SERVICE" || echo "WARNING: USER-SERVICE not registered"
                            kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -sf http://localhost:8761/eureka/apps | grep -q "PRODUCT-SERVICE" || echo "WARNING: PRODUCT-SERVICE not registered"
                            kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -sf http://localhost:8761/eureka/apps | grep -q "ORDER-SERVICE" || echo "WARNING: ORDER-SERVICE not registered"
                            kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -sf http://localhost:8761/eureka/apps | grep -q "PAYMENT-SERVICE" || echo "WARNING: PAYMENT-SERVICE not registered"
                            kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -sf http://localhost:8761/eureka/apps | grep -q "SHIPPING-SERVICE" || echo "WARNING: SHIPPING-SERVICE not registered"
                            kubectl exec -n ${K8S_NAMESPACE} deploy/service-discovery -- curl -sf http://localhost:8761/eureka/apps | grep -q "FAVOURITE-SERVICE" || echo "WARNING: FAVOURITE-SERVICE not registered"
                            
                            # Test API Gateway connectivity
                            echo "Testing API Gateway connectivity..."
                            retries=0
                            until curl -sf http://${gatewayUrl}/actuator/health || [ \$retries -ge 5 ]; do
                                echo "API Gateway not ready, waiting..."
                                sleep 30
                                retries=\$((retries + 1))
                            done
                            
                            if [ \$retries -ge 5 ]; then
                                echo "API Gateway not responding, but continuing with tests..."
                            fi
                            
                            cd tests
                            mvn clean verify -Pe2e-tests \\
                                -Dtest.base.url=http://${gatewayUrl} \\
                                -Dtest.timeout=60000
                        """
                    } else {
                        echo "Gateway URL not available, skipping E2E tests"
                    }
                }
            }
            post {
                always {
                    junit allowEmptyResults: true, testResults: 'tests/target/failsafe-reports/*.xml'
                }
            }
        }

        stage('Performance Tests') {
            steps {
                script {
                    def gatewayUrl = sh(
                        script: "kubectl get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo ''",
                        returnStdout: true
                    ).trim()

                    if (gatewayUrl) {
                        sh """
                            cd tests/performance
                            python3 -m pip install locust --quiet || true
                            locust -f locustfile.py --host=http://${gatewayUrl} \\
                                   --users 10 --spawn-rate 2 --run-time 60s --headless \\
                                   --html reports/performance_report.html || true
                        """
                    }
                }
            }
            post {
                always {
                    publishHTML([
                        allowMissing: true,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'tests/performance/reports',
                        reportFiles: 'performance_report.html',
                        reportName: 'Performance Test Reports'
                    ])
                }
            }
        }
    }

    post {
        success {
            script {
                echo "=== DEV DEPLOYMENT SUCCESS ==="

                // Parse and display deployed services
                try {
                    def slurper = new groovy.json.JsonSlurper()
                    def serviceVersions = slurper.parseText(params.SERVICE_VERSIONS)
                    def deployedServices = []
                    def skippedServices = []

                    serviceVersions.each { service, version ->
                        if (version != 'latest') {
                            deployedServices.add("${service}:${version}")
                        } else {
                            skippedServices.add("${service}:${version}")
                        }
                    }

                    echo "Deployed services (${deployedServices.size()}): ${deployedServices.join(', ')}"
                    echo "Skipped services (${skippedServices.size()}): ${skippedServices.join(', ')}"
                } catch (Exception e) {
                    echo "All services deployed: ${env.ALL_SERVICES}"
                }

                echo "Namespace: ${K8S_NAMESPACE}"
                echo "Cluster: ${K8S_CLUSTER}"
                echo "Full version map: ${params.SERVICE_VERSIONS}"
            }
        }
        failure {
            script {
                echo "DEV DEPLOYMENT FAILED"
                echo "Collecting diagnostic information..."
                
                sh """
                    echo "Pod status:"
                    kubectl get pods -n ${K8S_NAMESPACE} || true
                    
                    echo "Recent events:"
                    kubectl get events -n ${K8S_NAMESPACE} --sort-by=.firstTimestamp | tail -20 || true
                    
                    echo "Service status:"
                    kubectl get svc -n ${K8S_NAMESPACE} || true
                """
                
                echo "Attempting rollback..."
                def services = env.ALL_SERVICES.split(',')
                services.each { service ->
                    sh """
                        if kubectl get deployment ${service} -n ${K8S_NAMESPACE} > /dev/null 2>&1; then
                            echo "Rolling back ${service}..."
                            kubectl rollout undo deployment/${service} -n ${K8S_NAMESPACE} || echo 'Rollback failed for ${service}'
                        else
                            echo "Deployment ${service} not found, skipping rollback"
                        fi
                    """
                }
            }
        }
        always {
            deleteDir()
        }
    }
}