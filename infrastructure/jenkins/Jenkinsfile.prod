pipeline {
    agent any

    triggers {
        githubPush()
    }

    environment {
        AWS_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = '020951019497'
        ECR_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        K8S_NAMESPACE = 'production'
        SERVICES = 'service-discovery,cloud-config,user-service,product-service,order-service,payment-service,shipping-service,favourite-service,api-gateway'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                }
            }
        }

        stage('Detect Changed Services') {
            steps {
                script {
                    def changedFiles = sh(
                        script: '''
                            if git rev-parse HEAD~1 >/dev/null 2>&1; then
                                git diff --name-only HEAD~1 HEAD
                            else
                                echo "user-service/
product-service/
order-service/
payment-service/
shipping-service/
favourite-service/"
                            fi
                        ''',
                        returnStdout: true
                    ).trim()

                    echo "Changed files:\n${changedFiles}"

                    def services = env.SERVICES.split(',')
                    def changedServices = []

                    services.each { service ->
                        if (changedFiles.contains("${service}/") ||
                            changedFiles.contains("pom.xml") ||
                            changedFiles.contains("infrastructure/")) {
                            changedServices.add(service)
                        }
                    }

                    if (changedServices.isEmpty() && !changedFiles.isEmpty()) {
                        changedServices = services as List
                    }

                    if (changedServices.isEmpty()) {
                        currentBuild.result = 'NOT_BUILT'
                        error('No services changed - skipping build')
                    }

                    env.CHANGED_SERVICES = changedServices.join(',')
                    echo "Services to build and deploy: ${env.CHANGED_SERVICES}"

                    // Auto-generate version based on date and build number
                    env.VERSION = sh(
                        script: "date '+%Y.%m.%d'",
                        returnStdout: true
                    ).trim() + ".${BUILD_NUMBER}"

                    echo "Auto-generated version: ${env.VERSION}"
                }
            }
        }

        stage('Build service-discovery') {
            when {
                expression { env.CHANGED_SERVICES.contains('service-discovery') }
            }
            steps {
                sh "mvn clean install -pl service-discovery -am"
            }
        }

        stage('Unit Tests service-discovery') {
            when {
                expression { env.CHANGED_SERVICES.contains('service-discovery') }
            }
            steps {
                sh "mvn test -pl service-discovery"
            }
            post {
                always {
                    junit '**/target/*-reports/*.xml'
                }
            }
        }

        stage('Integration Tests service-discovery') {
            when {
                expression { env.CHANGED_SERVICES.contains('service-discovery') }
            }
            steps {
                sh "mvn verify -pl service-discovery -Pintegration-tests || echo 'No integration tests profile'"
            }
        }

        stage('Build cloud-config') {
            when {
                expression { env.CHANGED_SERVICES.contains('cloud-config') }
            }
            steps {
                sh "mvn clean install -pl cloud-config -am"
            }
        }

        stage('Unit Tests cloud-config') {
            when {
                expression { env.CHANGED_SERVICES.contains('cloud-config') }
            }
            steps {
                sh "mvn test -pl cloud-config"
            }
        }

        stage('Integration Tests cloud-config') {
            when {
                expression { env.CHANGED_SERVICES.contains('cloud-config') }
            }
            steps {
                sh "mvn verify -pl cloud-config -Pintegration-tests || echo 'No integration tests profile'"
            }
        }

        stage('Build user-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('user-service') }
            }
            steps {
                sh "mvn clean install -pl user-service -am"
            }
        }

        stage('Unit Tests user-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('user-service') }
            }
            steps {
                sh "mvn test -pl user-service"
            }
            post {
                always {
                    junit '**/target/*-reports/*.xml'
                }
            }
        }

        stage('Integration Tests user-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('user-service') }
            }
            steps {
                sh "mvn verify -pl user-service -Pintegration-tests || echo 'No integration tests profile'"
            }
        }

        stage('Build product-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('product-service') }
            }
            steps {
                sh "mvn clean install -pl product-service -am"
            }
        }

        stage('Unit Tests product-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('product-service') }
            }
            steps {
                sh "mvn test -pl product-service"
            }
        }

        stage('Integration Tests product-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('product-service') }
            }
            steps {
                sh "mvn verify -pl product-service -Pintegration-tests || echo 'No integration tests profile'"
            }
        }

        stage('Build order-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('order-service') }
            }
            steps {
                sh "mvn clean install -pl order-service -am"
            }
        }

        stage('Unit Tests order-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('order-service') }
            }
            steps {
                sh "mvn test -pl order-service"
            }
        }

        stage('Integration Tests order-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('order-service') }
            }
            steps {
                sh "mvn verify -pl order-service -Pintegration-tests || echo 'No integration tests profile'"
            }
        }

        stage('Build favourite-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('favourite-service') }
            }
            steps {
                sh "mvn clean install -pl favourite-service -am"
            }
        }

        stage('Unit Tests favourite-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('favourite-service') }
            }
            steps {
                sh "mvn test -pl favourite-service"
            }
        }

        stage('Integration Tests favourite-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('favourite-service') }
            }
            steps {
                sh "mvn verify -pl favourite-service -Pintegration-tests || echo 'No integration tests profile'"
            }
        }

        stage('Build payment-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('payment-service') }
            }
            steps {
                sh "mvn clean install -pl payment-service -am"
            }
        }

        stage('Unit Tests payment-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('payment-service') }
            }
            steps {
                sh "mvn test -pl payment-service"
            }
        }

        stage('Integration Tests payment-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('payment-service') }
            }
            steps {
                sh "mvn verify -pl payment-service -Pintegration-tests || echo 'No integration tests profile'"
            }
        }

        stage('Build shipping-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('shipping-service') }
            }
            steps {
                sh "mvn clean install -pl shipping-service -am"
            }
        }

        stage('Unit Tests shipping-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('shipping-service') }
            }
            steps {
                sh "mvn test -pl shipping-service"
            }
        }

        stage('Integration Tests shipping-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('shipping-service') }
            }
            steps {
                sh "mvn verify -pl shipping-service -Pintegration-tests || echo 'No integration tests profile'"
            }
        }

        stage('Build api-gateway') {
            when {
                expression { env.CHANGED_SERVICES.contains('api-gateway') }
            }
            steps {
                sh "mvn clean install -pl api-gateway -am"
            }
        }

        stage('Unit Tests api-gateway') {
            when {
                expression { env.CHANGED_SERVICES.contains('api-gateway') }
            }
            steps {
                sh "mvn test -pl api-gateway"
            }
            post {
                always {
                    junit '**/target/*-reports/*.xml'
                }
            }
        }

        stage('Integration Tests api-gateway') {
            when {
                expression { env.CHANGED_SERVICES.contains('api-gateway') }
            }
            steps {
                sh "mvn verify -pl api-gateway -Pintegration-tests || echo 'No integration tests profile'"
            }
        }

        stage('ECR Login') {
            steps {
                sh """
                    aws ecr get-login-password --region ${AWS_REGION} | \
                    docker login --username AWS --password-stdin ${ECR_REGISTRY}
                """
            }
        }

        stage('Docker Build service-discovery') {
            when {
                expression { env.CHANGED_SERVICES.contains('service-discovery') }
            }
            steps {
                script {
                    def imageTag = "v${env.VERSION}-${env.GIT_COMMIT_SHORT}"
                    sh """
                        docker build -t ${ECR_REGISTRY}/ecommerce/service-discovery:${imageTag} \
                                     -t ${ECR_REGISTRY}/ecommerce/service-discovery:v${env.VERSION} \
                                     -t ${ECR_REGISTRY}/ecommerce/service-discovery:production \
                                     -f service-discovery/Dockerfile .
                        docker push ${ECR_REGISTRY}/ecommerce/service-discovery:${imageTag}
                        docker push ${ECR_REGISTRY}/ecommerce/service-discovery:v${env.VERSION}
                        docker push ${ECR_REGISTRY}/ecommerce/service-discovery:production
                        docker rmi ${ECR_REGISTRY}/ecommerce/service-discovery:${imageTag} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/service-discovery:v${env.VERSION} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/service-discovery:production || true
                        docker builder prune -f
                    """
                }
            }
        }

        stage('Docker Build cloud-config') {
            when {
                expression { env.CHANGED_SERVICES.contains('cloud-config') }
            }
            steps {
                script {
                    def imageTag = "v${env.VERSION}-${env.GIT_COMMIT_SHORT}"
                    sh """
                        docker build -t ${ECR_REGISTRY}/ecommerce/cloud-config:${imageTag} \
                                     -t ${ECR_REGISTRY}/ecommerce/cloud-config:v${env.VERSION} \
                                     -t ${ECR_REGISTRY}/ecommerce/cloud-config:production \
                                     -f cloud-config/Dockerfile .
                        docker push ${ECR_REGISTRY}/ecommerce/cloud-config:${imageTag}
                        docker push ${ECR_REGISTRY}/ecommerce/cloud-config:v${env.VERSION}
                        docker push ${ECR_REGISTRY}/ecommerce/cloud-config:production
                        docker rmi ${ECR_REGISTRY}/ecommerce/cloud-config:${imageTag} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/cloud-config:v${env.VERSION} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/cloud-config:production || true
                        docker builder prune -f
                    """
                }
            }
        }

        stage('Docker Build user-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('user-service') }
            }
            steps {
                script {
                    def imageTag = "v${env.VERSION}-${env.GIT_COMMIT_SHORT}"
                    sh """
                        docker build -t ${ECR_REGISTRY}/ecommerce/user-service:${imageTag} \
                                     -t ${ECR_REGISTRY}/ecommerce/user-service:v${env.VERSION} \
                                     -t ${ECR_REGISTRY}/ecommerce/user-service:production \
                                     -f user-service/Dockerfile .
                        docker push ${ECR_REGISTRY}/ecommerce/user-service:${imageTag}
                        docker push ${ECR_REGISTRY}/ecommerce/user-service:v${env.VERSION}
                        docker push ${ECR_REGISTRY}/ecommerce/user-service:production
                        docker rmi ${ECR_REGISTRY}/ecommerce/user-service:${imageTag} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/user-service:v${env.VERSION} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/user-service:production || true
                        docker builder prune -f
                    """
                }
            }
        }

        stage('Docker Build product-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('product-service') }
            }
            steps {
                script {
                    def imageTag = "v${env.VERSION}-${env.GIT_COMMIT_SHORT}"
                    sh """
                        docker build -t ${ECR_REGISTRY}/ecommerce/product-service:${imageTag} \
                                     -t ${ECR_REGISTRY}/ecommerce/product-service:v${env.VERSION} \
                                     -t ${ECR_REGISTRY}/ecommerce/product-service:production \
                                     -f product-service/Dockerfile .
                        docker push ${ECR_REGISTRY}/ecommerce/product-service:${imageTag}
                        docker push ${ECR_REGISTRY}/ecommerce/product-service:v${env.VERSION}
                        docker push ${ECR_REGISTRY}/ecommerce/product-service:production
                        docker rmi ${ECR_REGISTRY}/ecommerce/product-service:${imageTag} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/product-service:v${env.VERSION} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/product-service:production || true
                        docker builder prune -f
                    """
                }
            }
        }

        stage('Docker Build order-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('order-service') }
            }
            steps {
                script {
                    def imageTag = "v${env.VERSION}-${env.GIT_COMMIT_SHORT}"
                    sh """
                        docker build -t ${ECR_REGISTRY}/ecommerce/order-service:${imageTag} \
                                     -t ${ECR_REGISTRY}/ecommerce/order-service:v${env.VERSION} \
                                     -t ${ECR_REGISTRY}/ecommerce/order-service:production \
                                     -f order-service/Dockerfile .
                        docker push ${ECR_REGISTRY}/ecommerce/order-service:${imageTag}
                        docker push ${ECR_REGISTRY}/ecommerce/order-service:v${env.VERSION}
                        docker push ${ECR_REGISTRY}/ecommerce/order-service:production
                        docker rmi ${ECR_REGISTRY}/ecommerce/order-service:${imageTag} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/order-service:v${env.VERSION} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/order-service:production || true
                        docker builder prune -f
                    """
                }
            }
        }

        stage('Docker Build favourite-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('favourite-service') }
            }
            steps {
                script {
                    def imageTag = "v${env.VERSION}-${env.GIT_COMMIT_SHORT}"
                    sh """
                        docker build -t ${ECR_REGISTRY}/ecommerce/favourite-service:${imageTag} \
                                     -t ${ECR_REGISTRY}/ecommerce/favourite-service:v${env.VERSION} \
                                     -t ${ECR_REGISTRY}/ecommerce/favourite-service:production \
                                     -f favourite-service/Dockerfile .
                        docker push ${ECR_REGISTRY}/ecommerce/favourite-service:${imageTag}
                        docker push ${ECR_REGISTRY}/ecommerce/favourite-service:v${env.VERSION}
                        docker push ${ECR_REGISTRY}/ecommerce/favourite-service:production
                        docker rmi ${ECR_REGISTRY}/ecommerce/favourite-service:${imageTag} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/favourite-service:v${env.VERSION} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/favourite-service:production || true
                        docker builder prune -f
                    """
                }
            }
        }

        stage('Docker Build payment-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('payment-service') }
            }
            steps {
                script {
                    def imageTag = "v${env.VERSION}-${env.GIT_COMMIT_SHORT}"
                    sh """
                        docker build -t ${ECR_REGISTRY}/ecommerce/payment-service:${imageTag} \
                                     -t ${ECR_REGISTRY}/ecommerce/payment-service:v${env.VERSION} \
                                     -t ${ECR_REGISTRY}/ecommerce/payment-service:production \
                                     -f payment-service/Dockerfile .
                        docker push ${ECR_REGISTRY}/ecommerce/payment-service:${imageTag}
                        docker push ${ECR_REGISTRY}/ecommerce/payment-service:v${env.VERSION}
                        docker push ${ECR_REGISTRY}/ecommerce/payment-service:production
                        docker rmi ${ECR_REGISTRY}/ecommerce/payment-service:${imageTag} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/payment-service:v${env.VERSION} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/payment-service:production || true
                        docker builder prune -f
                    """
                }
            }
        }

        stage('Docker Build shipping-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('shipping-service') }
            }
            steps {
                script {
                    def imageTag = "v${env.VERSION}-${env.GIT_COMMIT_SHORT}"
                    sh """
                        docker build -t ${ECR_REGISTRY}/ecommerce/shipping-service:${imageTag} \
                                     -t ${ECR_REGISTRY}/ecommerce/shipping-service:v${env.VERSION} \
                                     -t ${ECR_REGISTRY}/ecommerce/shipping-service:production \
                                     -f shipping-service/Dockerfile .
                        docker push ${ECR_REGISTRY}/ecommerce/shipping-service:${imageTag}
                        docker push ${ECR_REGISTRY}/ecommerce/shipping-service:v${env.VERSION}
                        docker push ${ECR_REGISTRY}/ecommerce/shipping-service:production
                        docker rmi ${ECR_REGISTRY}/ecommerce/shipping-service:${imageTag} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/shipping-service:v${env.VERSION} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/shipping-service:production || true
                        docker builder prune -f
                    """
                }
            }
        }

        stage('Docker Build api-gateway') {
            when {
                expression { env.CHANGED_SERVICES.contains('api-gateway') }
            }
            steps {
                script {
                    def imageTag = "v${env.VERSION}-${env.GIT_COMMIT_SHORT}"
                    sh """
                        docker build -t ${ECR_REGISTRY}/ecommerce/api-gateway:${imageTag} \
                                     -t ${ECR_REGISTRY}/ecommerce/api-gateway:v${env.VERSION} \
                                     -t ${ECR_REGISTRY}/ecommerce/api-gateway:production \
                                     -f api-gateway/Dockerfile .
                        docker push ${ECR_REGISTRY}/ecommerce/api-gateway:${imageTag}
                        docker push ${ECR_REGISTRY}/ecommerce/api-gateway:v${env.VERSION}
                        docker push ${ECR_REGISTRY}/ecommerce/api-gateway:production
                        docker rmi ${ECR_REGISTRY}/ecommerce/api-gateway:${imageTag} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/api-gateway:v${env.VERSION} || true
                        docker rmi ${ECR_REGISTRY}/ecommerce/api-gateway:production || true
                        docker builder prune -f
                    """
                }
            }
        }

        stage('Generate Release Notes') {
            steps {
                script {
                    def changedServices = env.CHANGED_SERVICES.split(',')

                    // Generate master release notes
                    sh """
                        cat > RELEASE_NOTES_v${VERSION}.md << 'NOTES'
# Production Release Notes - v${VERSION}

**Release Date:** \$(date '+%Y-%m-%d %H:%M:%S')
**Build:** #${BUILD_NUMBER}
**Commit:** ${GIT_COMMIT_SHORT}
**Services Updated:** ${CHANGED_SERVICES}

## Services Deployed

NOTES
                    """

                    // Generate release notes for each service
                    changedServices.each { service ->
                        def imageTag = "v${env.VERSION}-${env.GIT_COMMIT_SHORT}"
                        sh """
                            cat >> RELEASE_NOTES_v${VERSION}.md << 'NOTES'

### ${service}

**Docker Image:** ${ECR_REGISTRY}/ecommerce/${service}:${imageTag}

**Changes:**
\$(git log --pretty=format:"- %s (%an)" HEAD~5..HEAD -- ${service}/ | head -20 || echo "- Initial release")

NOTES
                        """
                    }

                    // Add common sections
                    sh """
                        cat >> RELEASE_NOTES_v${VERSION}.md << 'NOTES'

## Test Results

- Unit Tests: PASSED
- Integration Tests: PASSED

## Deployment

- **Environment:** Production
- **Namespace:** ${K8S_NAMESPACE}
- **Replicas:** 2

## Rollback Commands

NOTES
                    """

                    changedServices.each { service ->
                        sh """
                            cat >> RELEASE_NOTES_v${VERSION}.md << 'NOTES'
\`\`\`bash
# Rollback ${service}
kubectl rollout undo deployment/${service} -n ${K8S_NAMESPACE}
\`\`\`

NOTES
                        """
                    }

                    sh """
                        cat >> RELEASE_NOTES_v${VERSION}.md << 'NOTES'

---
*Generated automatically by Jenkins Pipeline*
NOTES

                        cat RELEASE_NOTES_v${VERSION}.md
                    """
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: "RELEASE_NOTES_*.md", fingerprint: true
                }
            }
        }
        
        stage('Manual Approval') {
            steps {
                script {
                    def releaseNotes = readFile("RELEASE_NOTES_v${VERSION}.md")

                    timeout(time: 30, unit: 'MINUTES') {
                        input message: """
                        Deploy v${VERSION} to PRODUCTION?

                        Services: ${CHANGED_SERVICES}

                        Review the release notes and confirm deployment.
                        """,
                        parameters: [
                            text(name: 'APPROVAL_NOTES', defaultValue: '', description: 'Add any notes about this deployment')
                        ]
                    }
                }
            }
        }

        stage('Deploy to Production') {
            steps {
                script {
                    def changedServices = env.CHANGED_SERVICES.split(',')
                    def imageTag = "v${env.VERSION}-${env.GIT_COMMIT_SHORT}"
                    def deploymentOrder = [
                        'service-discovery',
                        'cloud-config',
                        'user-service',
                        'product-service',
                        'order-service',
                        'favourite-service',
                        'payment-service',
                        'shipping-service',
                        'api-gateway'
                    ]

                    deploymentOrder.each { service ->
                        if (changedServices.contains(service)) {
                            echo "Deploying ${service} to production..."

                            // Check if deployment exists, if not create it
                            def deploymentExists = sh(
                                script: "kubectl get deployment ${service} -n ${K8S_NAMESPACE} 2>/dev/null",
                                returnStatus: true
                            )

                            if (deploymentExists != 0) {
                                echo "Deployment ${service} not found, creating from manifest..."
                                sh "kubectl apply -f infrastructure/kubernetes/base/${service}.yaml -n ${K8S_NAMESPACE}"
                            } else {
                                echo "Updating existing deployment ${service}..."
                                sh """
                                    kubectl set image deployment/${service} \
                                        ${service}=${ECR_REGISTRY}/ecommerce/${service}:${imageTag} \
                                        -n ${K8S_NAMESPACE}
                                """
                            }

                            sh "kubectl rollout status deployment/${service} -n ${K8S_NAMESPACE} --timeout=5m || echo 'Rollout status check failed'"

                            // Wait for critical infrastructure services
                            if (service == 'service-discovery') {
                                echo "Waiting 30s for Eureka to be fully ready..."
                                sleep 30
                            }
                            if (service == 'cloud-config') {
                                echo "Waiting 20s for Config Server to be fully ready..."
                                sleep 20
                            }
                        }
                    }
                }
            }
        }

        stage('Smoke Tests') {
            steps {
                script {
                    def changedServices = env.CHANGED_SERVICES.split(',')

                    changedServices.each { service ->
                        echo "Running smoke tests for ${service}..."
                        sh """
                            SERVICE_URL=\$(kubectl get svc ${service} -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || echo "localhost:8080")

                            curl -f http://\${SERVICE_URL}/actuator/health || echo "Health check failed for ${service}"
                            echo "Smoke tests passed for ${service}"
                        """
                    }
                }
            }
        }

        stage('Tag Git Release') {
            steps {
                script {
                    sh """
                        git tag -a v${VERSION} -m "Release v${VERSION} - Services: ${CHANGED_SERVICES}"
                        git push origin v${VERSION} || echo "Tag already exists"
                    """
                }
            }
        }

        stage('Clean Local Images') {
            steps {
                script {
                    def changedServices = env.CHANGED_SERVICES.split(',')
                    def imageTag = "v${env.VERSION}-${env.GIT_COMMIT_SHORT}"

                    changedServices.each { service ->
                        sh """
                            docker rmi ${ECR_REGISTRY}/ecommerce/${service}:${imageTag} || true
                            docker rmi ${ECR_REGISTRY}/ecommerce/${service}:v${VERSION} || true
                            docker rmi ${ECR_REGISTRY}/ecommerce/${service}:production || true
                        """
                    }
                }
            }
        }
    }
    
    post {
        success {
            script {
                echo """
                ===============================================================
                PRODUCTION DEPLOYMENT SUCCESS
                ===============================================================

                Version: v${VERSION}
                Services: ${CHANGED_SERVICES}
                Commit: ${GIT_COMMIT_SHORT}
                Namespace: ${K8S_NAMESPACE}

                Release Notes: RELEASE_NOTES_v${VERSION}.md

                ===============================================================
                """
            }
        }
        failure {
            script {
                echo "PRODUCTION DEPLOYMENT FAILED: v${VERSION}"
                echo "Services affected: ${CHANGED_SERVICES}"
                echo "Automatic rollback triggered..."

                def changedServices = env.CHANGED_SERVICES.split(',')
                changedServices.each { service ->
                    sh """
                        kubectl rollout undo deployment/${service} -n ${K8S_NAMESPACE} || echo "Rollback failed for ${service}"
                    """
                }
            }
        }
        always {
            deleteDir()
        }
    }
}
