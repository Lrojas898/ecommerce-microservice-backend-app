pipeline {
    agent any

    triggers {
        githubPush()
    }

    environment {
        AWS_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = '020951019497'
        ECR_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        IMAGE_TAG = "stage-${BUILD_NUMBER}"
        K8S_NAMESPACE = 'staging'
        SERVICES = 'user-service,product-service,order-service,payment-service,shipping-service,favourite-service'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                }
            }
        }

        stage('Detect Changed Services') {
            steps {
                script {
                    def changedFiles = sh(
                        script: '''
                            if git rev-parse HEAD~1 >/dev/null 2>&1; then
                                git diff --name-only HEAD~1 HEAD
                            else
                                echo "user-service/
product-service/
order-service/
payment-service/
shipping-service/
favourite-service/"
                            fi
                        ''',
                        returnStdout: true
                    ).trim()

                    echo "Changed files:\n${changedFiles}"

                    def services = env.SERVICES.split(',')
                    def changedServices = []

                    services.each { service ->
                        if (changedFiles.contains("${service}/") ||
                            changedFiles.contains("pom.xml") ||
                            changedFiles.contains("infrastructure/")) {
                            changedServices.add(service)
                        }
                    }

                    if (changedServices.isEmpty() && !changedFiles.isEmpty()) {
                        changedServices = services as List
                    }

                    if (changedServices.isEmpty()) {
                        currentBuild.result = 'NOT_BUILT'
                        error('No services changed - skipping build')
                    }

                    env.CHANGED_SERVICES = changedServices.join(',')
                    echo "Services to build and deploy: ${env.CHANGED_SERVICES}"
                }
            }
        }
        
        stage('Build user-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('user-service') }
            }
            steps {
                sh "mvn clean install -pl user-service -am -DskipTests"
            }
        }

        stage('Test user-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('user-service') }
            }
            steps {
                sh "mvn test -pl user-service"
                sh "mvn verify -pl user-service -Pintegration-tests || echo 'No integration tests'"
            }
            post {
                always {
                    junit '**/target/surefire-reports/*.xml'
                    junit allowEmptyResults: true, testResults: '**/target/failsafe-reports/*.xml'
                }
            }
        }

        stage('Build product-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('product-service') }
            }
            steps {
                sh "mvn clean install -pl product-service -am -DskipTests"
            }
        }

        stage('Test product-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('product-service') }
            }
            steps {
                sh "mvn test -pl product-service"
                sh "mvn verify -pl product-service -Pintegration-tests || echo 'No integration tests'"
            }
        }

        stage('Build order-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('order-service') }
            }
            steps {
                sh "mvn clean install -pl order-service -am -DskipTests"
            }
        }

        stage('Test order-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('order-service') }
            }
            steps {
                sh "mvn test -pl order-service"
                sh "mvn verify -pl order-service -Pintegration-tests || echo 'No integration tests'"
            }
        }

        stage('Build favourite-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('favourite-service') }
            }
            steps {
                sh "mvn clean install -pl favourite-service -am -DskipTests"
            }
        }

        stage('Test favourite-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('favourite-service') }
            }
            steps {
                sh "mvn test -pl favourite-service"
                sh "mvn verify -pl favourite-service -Pintegration-tests || echo 'No integration tests'"
            }
        }

        stage('Build payment-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('payment-service') }
            }
            steps {
                sh "mvn clean install -pl payment-service -am -DskipTests"
            }
        }

        stage('Test payment-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('payment-service') }
            }
            steps {
                sh "mvn test -pl payment-service"
                sh "mvn verify -pl payment-service -Pintegration-tests || echo 'No integration tests'"
            }
        }

        stage('Build shipping-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('shipping-service') }
            }
            steps {
                sh "mvn clean install -pl shipping-service -am -DskipTests"
            }
        }

        stage('Test shipping-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('shipping-service') }
            }
            steps {
                sh "mvn test -pl shipping-service"
                sh "mvn verify -pl shipping-service -Pintegration-tests || echo 'No integration tests'"
            }
        }

        stage('ECR Login') {
            steps {
                sh """
                    aws ecr get-login-password --region ${AWS_REGION} | \
                    docker login --username AWS --password-stdin ${ECR_REGISTRY}
                """
            }
        }

        stage('Docker Build user-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('user-service') }
            }
            steps {
                sh """
                    docker build -t ${ECR_REGISTRY}/ecommerce/user-service:${IMAGE_TAG} \
                                 -t ${ECR_REGISTRY}/ecommerce/user-service:staging \
                                 -f user-service/Dockerfile .
                    docker push ${ECR_REGISTRY}/ecommerce/user-service:${IMAGE_TAG}
                    docker push ${ECR_REGISTRY}/ecommerce/user-service:staging
                    docker rmi ${ECR_REGISTRY}/ecommerce/user-service:${IMAGE_TAG} || true
                    docker rmi ${ECR_REGISTRY}/ecommerce/user-service:staging || true
                    docker builder prune -f
                """
            }
        }

        stage('Docker Build product-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('product-service') }
            }
            steps {
                sh """
                    docker build -t ${ECR_REGISTRY}/ecommerce/product-service:${IMAGE_TAG} \
                                 -t ${ECR_REGISTRY}/ecommerce/product-service:staging \
                                 -f product-service/Dockerfile .
                    docker push ${ECR_REGISTRY}/ecommerce/product-service:${IMAGE_TAG}
                    docker push ${ECR_REGISTRY}/ecommerce/product-service:staging
                    docker rmi ${ECR_REGISTRY}/ecommerce/product-service:${IMAGE_TAG} || true
                    docker rmi ${ECR_REGISTRY}/ecommerce/product-service:staging || true
                    docker builder prune -f
                """
            }
        }

        stage('Docker Build order-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('order-service') }
            }
            steps {
                sh """
                    docker build -t ${ECR_REGISTRY}/ecommerce/order-service:${IMAGE_TAG} \
                                 -t ${ECR_REGISTRY}/ecommerce/order-service:staging \
                                 -f order-service/Dockerfile .
                    docker push ${ECR_REGISTRY}/ecommerce/order-service:${IMAGE_TAG}
                    docker push ${ECR_REGISTRY}/ecommerce/order-service:staging
                    docker rmi ${ECR_REGISTRY}/ecommerce/order-service:${IMAGE_TAG} || true
                    docker rmi ${ECR_REGISTRY}/ecommerce/order-service:staging || true
                    docker builder prune -f
                """
            }
        }

        stage('Docker Build favourite-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('favourite-service') }
            }
            steps {
                sh """
                    docker build -t ${ECR_REGISTRY}/ecommerce/favourite-service:${IMAGE_TAG} \
                                 -t ${ECR_REGISTRY}/ecommerce/favourite-service:staging \
                                 -f favourite-service/Dockerfile .
                    docker push ${ECR_REGISTRY}/ecommerce/favourite-service:${IMAGE_TAG}
                    docker push ${ECR_REGISTRY}/ecommerce/favourite-service:staging
                    docker rmi ${ECR_REGISTRY}/ecommerce/favourite-service:${IMAGE_TAG} || true
                    docker rmi ${ECR_REGISTRY}/ecommerce/favourite-service:staging || true
                    docker builder prune -f
                """
            }
        }

        stage('Docker Build payment-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('payment-service') }
            }
            steps {
                sh """
                    docker build -t ${ECR_REGISTRY}/ecommerce/payment-service:${IMAGE_TAG} \
                                 -t ${ECR_REGISTRY}/ecommerce/payment-service:staging \
                                 -f payment-service/Dockerfile .
                    docker push ${ECR_REGISTRY}/ecommerce/payment-service:${IMAGE_TAG}
                    docker push ${ECR_REGISTRY}/ecommerce/payment-service:staging
                    docker rmi ${ECR_REGISTRY}/ecommerce/payment-service:${IMAGE_TAG} || true
                    docker rmi ${ECR_REGISTRY}/ecommerce/payment-service:staging || true
                    docker builder prune -f
                """
            }
        }

        stage('Docker Build shipping-service') {
            when {
                expression { env.CHANGED_SERVICES.contains('shipping-service') }
            }
            steps {
                sh """
                    docker build -t ${ECR_REGISTRY}/ecommerce/shipping-service:${IMAGE_TAG} \
                                 -t ${ECR_REGISTRY}/ecommerce/shipping-service:staging \
                                 -f shipping-service/Dockerfile .
                    docker push ${ECR_REGISTRY}/ecommerce/shipping-service:${IMAGE_TAG}
                    docker push ${ECR_REGISTRY}/ecommerce/shipping-service:staging
                    docker rmi ${ECR_REGISTRY}/ecommerce/shipping-service:${IMAGE_TAG} || true
                    docker rmi ${ECR_REGISTRY}/ecommerce/shipping-service:staging || true
                    docker builder prune -f
                """
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    def changedServices = env.CHANGED_SERVICES.split(',')
                    def deploymentOrder = [
                        'service-discovery',
                        'cloud-config',
                        'user-service',
                        'product-service',
                        'order-service',
                        'favourite-service',
                        'payment-service',
                        'shipping-service',
                        'api-gateway'
                    ]

                    deploymentOrder.each { service ->
                        if (changedServices.contains(service)) {
                            echo "Deploying ${service} to ${K8S_NAMESPACE}..."
                            sh """
                                kubectl set image deployment/${service} \
                                    ${service}=${ECR_REGISTRY}/ecommerce/${service}:${IMAGE_TAG} \
                                    -n ${K8S_NAMESPACE} || echo "Deployment ${service} not found - skipping"

                                kubectl rollout status deployment/${service} -n ${K8S_NAMESPACE} --timeout=5m || echo "Rollout status check failed"
                            """

                            if (service == 'service-discovery' || service == 'cloud-config') {
                                echo "Waiting for ${service} to be ready..."
                                sleep 10
                            }
                        }
                    }
                }
            }
        }

        stage('E2E Tests') {
            steps {
                script {
                    def changedServices = env.CHANGED_SERVICES.split(',')

                    changedServices.each { service ->
                        echo "Running E2E tests for ${service}..."
                        sh """
                            mvn verify -pl ${service} -Pe2e-tests \
                                -Dtest.base.url=http://${service}.${K8S_NAMESPACE}.svc.cluster.local || echo "No E2E tests for ${service}"
                        """
                    }
                }
            }
            post {
                always {
                    junit allowEmptyResults: true, testResults: '**/target/e2e-reports/*.xml'
                }
            }
        }

        stage('Performance Tests') {
            steps {
                script {
                    def changedServices = env.CHANGED_SERVICES.split(',')

                    changedServices.each { service ->
                        echo "Running performance tests for ${service}..."
                        sh """
                            SERVICE_URL=\$(kubectl get svc ${service} -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || echo "localhost:8080")

                            cd tests/performance
                            locust -f locustfile.py --headless \
                                --users 50 --spawn-rate 5 --run-time 2m \
                                --host http://\${SERVICE_URL} \
                                --html reports/${service}-performance-${BUILD_NUMBER}.html || echo "Performance tests skipped for ${service}"
                        """
                    }
                }
            }
            post {
                always {
                    script {
                        try {
                            publishHTML([
                                reportDir: 'tests/performance/reports',
                                reportFiles: '*-performance-*.html',
                                reportName: 'Performance Test Reports'
                            ])
                        } catch (Exception e) {
                            echo "No performance reports to publish"
                        }
                    }
                }
            }
        }

        stage('Clean Local Images') {
            steps {
                script {
                    def changedServices = env.CHANGED_SERVICES.split(',')

                    changedServices.each { service ->
                        sh """
                            docker rmi ${ECR_REGISTRY}/ecommerce/${service}:${IMAGE_TAG} || true
                            docker rmi ${ECR_REGISTRY}/ecommerce/${service}:staging || true
                        """
                    }
                }
            }
        }
    }
    
    post {
        success {
            script {
                echo "STAGING DEPLOYMENT SUCCESS: ${env.CHANGED_SERVICES}"
                echo "Image tag: ${IMAGE_TAG}"
                echo "Namespace: ${K8S_NAMESPACE}"
            }
        }
        failure {
            script {
                echo "STAGING DEPLOYMENT FAILED for one or more services in: ${env.CHANGED_SERVICES}"
                // Rollback changed services
                def changedServices = env.CHANGED_SERVICES.split(',')
                changedServices.each { service ->
                    sh """
                        kubectl rollout undo deployment/${service} -n ${K8S_NAMESPACE} || echo "Rollback failed for ${service}"
                    """
                }
            }
        }
        always {
            deleteDir()
        }
    }
}
